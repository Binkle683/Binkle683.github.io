<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Smart Planting Shelf IoT Dashboard</title>
    <script src="https://unpkg.com/mqtt/dist/mqtt.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@3.9.1/dist/chart.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@2.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <style>

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            opacity: 0.9;
            font-size: 1.1em;
        }

        .status-bar {
            background: #f8f9fa;
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 2px solid #e9ecef;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            display: inline-block;
        }

        .status-dot.connected {
            background: #28a745;
            box-shadow: 0 0 10px #28a745;
        }

        .status-dot.disconnected {
            background: #dc3545;
        }

        .status-dot.connecting {
            background: #ffc107;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .content {
            padding: 30px;
        }

        .sensors-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        @media (min-width: 768px) {
            .sensors-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
        
        /* Special grid for centered cards in trends page */
        .trends-analysis-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            margin-bottom: 30px;
            justify-items: center;
        }
        
        @media (min-width: 768px) {
            .trends-analysis-grid {
                grid-template-columns: repeat(2, 1fr);
                max-width: 1400px;
                margin-left: auto;
                margin-right: auto;
            }
        }
        
        .trends-analysis-grid .heat-stress-card,
        .trends-analysis-grid .light-accumulation-card {
            grid-column: span 1;
            width: 100%;
            max-width: 600px;
        }

        .sensor-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .sensor-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
        }

        .sensor-card.active {
            background: linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%);
            border: 2px solid #28a745;
        }

        .sensor-card.alert {
            background: linear-gradient(135deg, #f8d7da 0%, #f5c6cb 100%);
            border: 2px solid #dc3545;
            animation: alertPulse 2s infinite;
        }

        @keyframes alertPulse {
            0%, 100% { box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
            50% { box-shadow: 0 4px 20px rgba(220, 53, 69, 0.6); }
        }

        .sensor-icon {
            font-size: 3em;
            margin-bottom: 15px;
            text-align: center;
        }

        .sensor-title {
            font-size: 1.1em;
            color: #495057;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .sensor-value {
            font-size: 2em;
            font-weight: bold;
            color: #667eea;
            text-align: center;
            margin: 10px 0;
        }

        .sensor-status {
            text-align: center;
            font-size: 0.9em;
            padding: 5px 15px;
            border-radius: 20px;
            display: inline-block;
            margin-top: 10px;
        }

        .sensor-status.on {
            background: #28a745;
            color: white;
        }

        .sensor-status.off {
            background: #6c757d;
            color: white;
        }

        .sensor-status.detected {
            background: #ffc107;
            color: #333;
        }

        .temperature-display {
            text-align: center;
            margin: 40px 0;
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            padding: 30px;
            border-radius: 15px;
        }

        .temperature-value {
            font-size: 6em;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .temperature-unit {
            font-size: 3em;
            color: #6c757d;
            margin-left: 10px;
        }

        .chart-container {
            margin-top: 40px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
        }

        .chart-title {
            font-size: 1.5em;
            margin-bottom: 20px;
            color: #333;
            text-align: center;
        }

        .alert-section {
            margin-top: 0;
            margin-bottom: 0;
            background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
            border: 2px solid #ffc107;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .alert-section h3 {
            color: #856404;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-section.sensor-card {
            display: flex;
            flex-direction: column;
        }

        .alert-section.sensor-card .sensor-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .alert-section.sensor-card .sensor-title {
            font-size: 1.2em;
            margin-bottom: 15px;
            color: #856404;
        }

        .alert-list {
            max-height: 200px;
            overflow-y: auto;
        }

        .alert-item {
            padding: 10px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            border-left: 4px solid #dc3545;
            font-size: 0.9em;
        }

        .alert-item .alert-time {
            color: #6c757d;
            font-size: 0.85em;
            margin-bottom: 5px;
        }

        .alert-item .alert-message {
            color: #dc3545;
            font-weight: 600;
        }
        
        .alert-item.resolved {
            opacity: 0.6;
            background: #f8f9fa;
        }
        
        .alert-item.resolved .alert-message {
            color: #6c757d;
        }
        
        .alert-item .alert-status {
            color: #28a745;
            font-size: 0.85em;
            margin-top: 5px;
            font-style: italic;
        }

        .message-log {
            margin-top: 0;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .message-log h3 {
            margin-bottom: 15px;
            color: #333;
            font-size: 1.2em;
            border-bottom: 2px solid #dee2e6;
            padding-bottom: 10px;
        }

        .log-entry {
            padding: 8px;
            margin: 5px 0;
            background: white;
            border-radius: 5px;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
            color: #495057;
        }

        .log-entry.error {
            background: #fee;
            color: #c33;
        }

        .log-entry.success {
            background: #efe;
            color: #3c3;
        }

        /* RGB LED control button styles */
        #rgbLedSetBtn:hover {
            background: #5568d3 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #rgbLedAutoBtn:hover {
            background: #218838 !important;
            transform: translateY(-1px);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        #rgbLedSetBtn:active, #rgbLedAutoBtn:active {
            transform: translateY(0);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .environment-card {
            grid-column: span 2;
        }

        .environment-sensors-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 10px;
        }

        .security-card {
            grid-column: span 2;
        }

        .security-sensors-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 10px;
        }

        /* Heat Stress Card Styles */
        .heat-stress-card {
            grid-column: span 2;
            background: linear-gradient(135deg, #fff5f5 0%, #ffe5e5 100%);
            border: 2px solid #ff6b6b;
        }

        .heat-stress-card.moderate {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border: 2px solid #ffa726;
        }

        .heat-stress-card.safe {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #66bb6a;
        }

        /* Light Accumulation Card Styles */
        .light-accumulation-card {
            grid-column: span 2;
            background: linear-gradient(135deg, #fffbf0 0%, #fff8e1 100%);
            border: 2px solid #ffc107;
        }

        .light-accumulation-card.moderate {
            background: linear-gradient(135deg, #fff8e1 0%, #ffecb3 100%);
            border: 2px solid #ffa726;
        }

        .light-accumulation-card.safe {
            background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
            border: 2px solid #66bb6a;
        }

        .light-accumulation-card.high {
            background: linear-gradient(135deg, #fff5f5 0%, #ffe5e5 100%);
            border: 2px solid #ff6b6b;
        }

        /* Tab Navigation Styles */
        .tabs {
            display: flex;
            gap: 0;
            background: #f8f9fa;
            border-bottom: 2px solid #dee2e6;
            padding: 0;
            margin: 0;
        }

        .tab-btn {
            flex: 1;
            padding: 15px 20px;
            background: transparent;
            border: none;
            border-bottom: 3px solid transparent;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.3s;
        }

        .tab-btn:hover {
            background: #e9ecef;
            color: #495057;
        }

        .tab-btn.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: white;
        }
        
        /* RGB LED Mode Tabs */
        .rgb-mode-tab {
            flex: 1;
            padding: 10px 15px;
            background: transparent;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            color: #6c757d;
            transition: all 0.3s;
        }
        
        .rgb-mode-tab:hover {
            background: #f8f9fa;
            color: #495057;
        }
        
        .rgb-mode-tab.active {
            color: #667eea;
            border-bottom-color: #667eea;
            background: #f8f9fa;
        }
        
        .rgb-mode-panel {
            display: none;
        }
        
        .rgb-mode-panel.active {
            display: block;
        }
        
        /* Temperature Threshold Preset Buttons */
        .temp-preset-btn {
            flex: 1;
            min-width: 60px;
            padding: 8px 12px;
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            color: #495057;
            transition: all 0.2s;
        }
        
        .temp-preset-btn:hover {
            background: #e9ecef;
            border-color: #667eea;
            color: #667eea;
            transform: translateY(-1px);
        }
        
        .temp-preset-btn.active {
            background: linear-gradient(135deg, #667eea 0%, #5568d3 100%);
            border-color: #667eea;
            color: white;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3);
        }
        
        /* Temperature Threshold Slider Styling */
        #tempThresholdSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #5568d3 100%);
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
            border: 2px solid white;
            transition: all 0.2s;
        }
        
        #tempThresholdSlider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.5);
        }
        
        #tempThresholdSlider::-moz-range-thumb {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #5568d3 100%);
            cursor: pointer;
            border: 2px solid white;
            box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
            transition: all 0.2s;
        }
        
        #tempThresholdSlider::-moz-range-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 3px 8px rgba(102, 126, 234, 0.5);
        }
        
        #tempThresholdSetBtn:hover {
            background: linear-gradient(135deg, #5568d3 0%, #4a5bc4 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.4);
        }
        
        #tempThresholdSetBtn:active {
            transform: translateY(0);
        }

        /* Page Sections */
        .page {
            display: none;
            padding: 30px;
        }

        .page.active {
            display: block;
        }

        /* Dashboard Page Styles */
        .dashboard-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 30px;
            margin-bottom: 30px;
        }

        .dashboard-card {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .dashboard-card h3 {
            font-size: 1.2em;
            color: #6c757d;
            margin-bottom: 20px;
        }

        .dashboard-value {
            font-size: 5em;
            font-weight: bold;
            color: #667eea;
            margin: 20px 0;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.1);
        }

        .dashboard-unit {
            font-size: 2em;
            color: #6c757d;
            margin-left: 10px;
        }

        .status-indicator {
            display: inline-block;
            padding: 10px 20px;
            border-radius: 25px;
            font-weight: 600;
            font-size: 1.1em;
            margin-top: 20px;
        }

        .status-indicator.online {
            background: #28a745;
            color: white;
        }

        .status-indicator.offline {
            background: #dc3545;
            color: white;
        }

        /* Hide Air Quality Badge in Dashboard */
        #dashboardAirQualityBadge {
            display: none !important;
        }

        /* Events Page Styles */
        .events-list {
            max-height: 600px;
            overflow-y: auto;
        }

        .event-item {
            padding: 20px;
            margin-bottom: 15px;
            background: white;
            border-radius: 10px;
            border-left: 5px solid #667eea;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .event-item.event {
            border-left-color: #ffc107;
        }

        .event-item.action {
            border-left-color: #28a745;
        }

        .event-item.alert {
            border-left-color: #dc3545;
        }

        .event-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .event-time {
            color: #6c757d;
            font-size: 0.9em;
        }

        .event-type {
            display: inline-block;
            padding: 5px 15px;
            border-radius: 15px;
            font-size: 0.85em;
            font-weight: 600;
        }

        .event-type.event {
            background: #fff3cd;
            color: #856404;
        }

        .event-type.action {
            background: #d4edda;
            color: #155724;
        }

        .event-type.alert {
            background: #f8d7da;
            color: #721c24;
        }

        .event-message {
            font-size: 1.1em;
            color: #495057;
            margin: 10px 0;
        }

        .event-snapshot {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 0.9em;
            color: #6c757d;
        }

        .heat-stress-content {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            padding: 10px;
        }

        .heat-stress-item {
            text-align: center;
        }

        .heat-stress-value {
            font-size: 2.5em;
            font-weight: bold;
            color: #dc3545;
            margin: 10px 0;
        }

        .heat-stress-item.moderate .heat-stress-value {
            color: #ff9800;
        }

        .heat-stress-item.safe .heat-stress-value {
            color: #28a745;
        }

        .heat-stress-label {
            font-size: 0.9em;
            color: #6c757d;
            margin-bottom: 5px;
        }

        .heat-stress-recommendation {
            margin-top: 15px;
            padding: 15px;
            background: white;
            border-radius: 10px;
            border-left: 4px solid #ff6b6b;
        }

        .heat-stress-recommendation.moderate {
            border-left-color: #ffa726;
        }

        .heat-stress-recommendation.safe {
            border-left-color: #66bb6a;
        }

        .why-button {
            margin-top: 10px;
            padding: 5px 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.85em;
            transition: background 0.3s;
        }

        .why-button:hover {
            background: #5568d3;
        }

        .why-explanation {
            margin-top: 10px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 5px;
            font-size: 0.85em;
            color: #495057;
            display: none;
        }

        .why-explanation.show {
            display: block;
        }

        @media (max-width: 768px) {
            .status-bar {
                flex-direction: column;
            }

            .header h1 {
                font-size: 1.8em;
            }

            .sensors-grid {
                grid-template-columns: 1fr;
            }

            .environment-card {
                grid-column: span 1 !important;
            }

            .environment-sensors-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }

            .environment-card .sensor-value {
                font-size: 2em !important;
            }

            .security-card {
                grid-column: span 1 !important;
            }

            .security-sensors-grid {
                grid-template-columns: 1fr !important;
                gap: 15px !important;
            }

            .security-card .sensor-value {
                font-size: 1.5em !important;
            }

            .trends-analysis-grid .heat-stress-card {
                grid-column: span 1 !important;
            }

            .heat-stress-content {
                grid-template-columns: 1fr !important;
            }

            .trends-analysis-grid .light-accumulation-card {
                grid-column: span 1 !important;
            }

            /* On small screens, charts switch to single column display */
            .chart-container {
                flex: 1 1 100% !important;
            }
        }
    

/* ============================
   Visual polish (no JS changes)
   ============================ */
:root{
  --bg: #f6f8fb;
  --surface: #ffffff;
  --text: #111827;
  --muted: #6b7280;
  --border: rgba(17,24,39,.10);

  --primary: #4f46e5;
  --primary-2: #7c3aed;
  --success: #16a34a;
  --warning: #f59e0b;
  --danger: #dc2626;

  --radius: 18px;
  --radius-sm: 12px;
  --shadow: 0 14px 36px rgba(0,0,0,.10);
  --shadow-soft: 0 10px 26px rgba(0,0,0,.08);
  --shadow-hover: 0 18px 44px rgba(0,0,0,.14);
}

/* Base typography + background */
body{
  font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI",
               "PingFang SC","Microsoft YaHei", Arial, sans-serif;
  line-height: 1.55;
  color: var(--text);
  background:
    radial-gradient(1100px 700px at 12% -10%, rgba(79,70,229,.18), transparent 62%),
    radial-gradient(1100px 700px at 92% -5%, rgba(124,58,237,.14), transparent 58%),
    radial-gradient(900px 600px at 80% 110%, rgba(22,163,74,.12), transparent 55%),
    var(--bg);
  padding: 24px;
  -webkit-font-smoothing: antialiased;
  text-rendering: optimizeLegibility;
}

/* Container: softer shadow + consistent radius */
.container{
  border-radius: calc(var(--radius) + 2px);
  box-shadow: var(--shadow);
  background: var(--surface);
  border: 1px solid var(--border);
}

/* Header: keep gradient, refine text */
.header{
  background: linear-gradient(135deg, var(--primary) 0%, var(--primary-2) 100%);
}
.header h1{
  letter-spacing: .2px;
}
.header p{
  color: rgba(255,255,255,.88);
}

/* Sticky glass status bar */
.status-bar{
  position: sticky;
  top: 0;
  z-index: 50;
  background: rgba(246,248,251,.78);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border-bottom: 1px solid var(--border);
}
.status-item span{
  color: rgba(17,24,39,.82);
  font-weight: 600;
}
.status-dot.connected{
  background: var(--success);
  box-shadow: 0 0 12px rgba(22,163,74,.55);
}
.status-dot.disconnected{
  background: var(--danger);
  box-shadow: 0 0 12px rgba(220,38,38,.45);
}

/* Section spacing: slightly airier */
.dashboard{
  background: transparent;
}
.section-title{
  color: rgba(17,24,39,.92);
  letter-spacing: .2px;
}

/* Cards: white surface + subtle border, status tint */
.sensor-card{
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: var(--radius);
  box-shadow: var(--shadow-soft);
  transition: transform .18s ease, box-shadow .18s ease, border-color .18s ease, background .18s ease;
}
.sensor-card:hover{
  transform: translateY(-3px);
  box-shadow: var(--shadow-hover);
}
.sensor-card.active{
  border-color: rgba(22,163,74,.35);
  background: linear-gradient(180deg, rgba(22,163,74,.10), #fff 55%);
}
.sensor-card.alert{
  border-color: rgba(220,38,38,.35);
  background: linear-gradient(180deg, rgba(220,38,38,.10), #fff 55%);
}

/* Card text alignment and hierarchy */
.sensor-title{
  font-weight: 700;
  color: rgba(17,24,39,.88);
  min-height: 44px;
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
}
.sensor-value{
  font-size: clamp(1.6rem, 2.6vw, 2.45rem);
  letter-spacing: .2px;
}
.sensor-unit{
  color: rgba(17,24,39,.55);
}
.sensor-icon{
  filter: saturate(1.05);
  opacity: .95;
}

/* Panels / forms: consistent rounding */
.control-panel, .chart-container, .analysis-section, .log-section{
  border-radius: var(--radius);
  border: 1px solid var(--border);
  box-shadow: var(--shadow-soft);
  background: rgba(255,255,255,.92);
}

/* Inputs & buttons: unified feel */
input, select, textarea{
  border-radius: 12px;
  border: 1px solid rgba(17,24,39,.16);
  background: rgba(255,255,255,.95);
}
input:focus-visible, select:focus-visible, textarea:focus-visible{
  outline: 3px solid rgba(79,70,229,.22);
  outline-offset: 2px;
}

button{
  border-radius: 12px;
  border: 1px solid rgba(17,24,39,.14);
  box-shadow: 0 6px 14px rgba(0,0,0,.10);
  transition: transform .15s ease, box-shadow .15s ease, filter .15s ease;
}
button:hover{
  transform: translateY(-1px);
  box-shadow: 0 10px 22px rgba(0,0,0,.14);
}
button:active{
  transform: translateY(0);
}
button:focus-visible{
  outline: 3px solid rgba(79,70,229,.22);
  outline-offset: 2px;
}

/* Subtle separators */
hr{
  border: 0;
  height: 1px;
  background: rgba(17,24,39,.10);
}

/* Reduce motion for accessibility */
@media (prefers-reduced-motion: reduce){
  *{
    animation-duration: .001ms !important;
    animation-iteration-count: 1 !important;
    transition-duration: .001ms !important;
    scroll-behavior: auto !important;
  }
}

/* Make dashboard cards align nicely */
.dashboard-grid{
  align-items: stretch; /* ËÆ©Âêå‰∏ÄË°åÁöÑ card È´òÂ∫¶‰∏ÄËá¥ */
}

.dashboard-card{
  display: flex;
  flex-direction: column;
  align-items: center;
  height: 100%;
  min-height: 320px; /* ‰Ω†ÂèØ‰ª•ÊåâÂñúÂ•ΩË∞ÉÔºåÊØîÂ¶Ç 300~340 */
}

/* Áªü‰∏ÄÊ†áÈ¢òÂç†‰ΩçÔºöÈÅøÂÖçÊúâÁöÑÊ†áÈ¢ò‰∏§Ë°å„ÄÅÊúâÁöÑ‰∏ÄË°åÂØºËá¥Èîô‰Ωç */
.dashboard-card h3{
  min-height: 56px;           /* ÂÖ≥ÈîÆÔºöÂõ∫ÂÆöÊ†áÈ¢òÂå∫ÂüüÈ´òÂ∫¶ */
  display: flex;
  align-items: center;
  justify-content: center;
  margin-bottom: 12px;
  line-height: 1.2;
}

/* Êï∞ÂÄºÂå∫ÂüüÔºöËÆ©Â§ßÊï∞Â≠óÂú®ÊØèÂº†Âç°ÈáåÈÉΩËêΩÂú®Âêå‰∏Ä"‰∏≠Á∫ø" */
.dashboard-card > div:nth-of-type(1){
  flex: 1;                    /* ÂÖ≥ÈîÆÔºöÊï∞ÂÄºÂå∫ÊíëÂºÄÂπ∂Â±Ö‰∏≠ */
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
}

/* Á¨¨‰∫åÂùóÂå∫ÂüüÔºàAir Quality ÁöÑ badge ÈÇ£ÂùóÔºâÁªôÂõ∫ÂÆöÂç†‰ΩçÔºå
   Âç≥‰Ωø‰Ω†‰ª•ÂêéÈöêËóè badgeÔºå‰πüËÉΩ‰øùÊåÅÂç°ÁâáÂÜÖÂØπÈΩê */
.dashboard-card > div:nth-of-type(2){
  min-height: 60px;
  display: flex;
  align-items: center;
  justify-content: center;
  margin-top: 12px !important;  /* Ë¶ÜÁõñ‰Ω† HTML ÈáåÂÜôÊ≠ªÁöÑ margin-top:15px */
}

/* ÂéªÊéâ status-indicator Ëá™Â∏¶ÁöÑ margin-topÔºåÈÅøÂÖçÊää badge ÂÜçÂæÄ‰∏ãÈ°∂ */
.status-indicator{
  margin-top: 0;
}

/* ========== Make Trends analysis cards look aligned ========== */

/* ËÆ©‰∏§Âº†ÂàÜÊûêÂç°ÂêåÈ´ò„ÄÅÂÜÖÂÆπËá™‰∏äËÄå‰∏ãÊéíÁâà */
.trends-analysis-grid{
  align-items: stretch;
}
.trends-analysis-grid > .sensor-card{
  display: flex;
  flex-direction: column;
  height: 100%;
}

/* Áªü‰∏ÄÂàÜÊûêÂç°Ê†áÈ¢òÔºàË¶ÜÁõñ‰Ω†ÂÜôÂú® inline style ÈáåÁöÑ spacingÔºâ */
.trends-analysis-grid .sensor-title{
  text-align: center !important;
  margin-bottom: 18px !important;
  line-height: 1.2;
}

/* ÊåáÊ†áÂå∫ÂüüÔºö‰ªçÁÑ∂ 3 ÂàóÔºå‰ΩÜËÆ©Â∏ÉÂ±ÄÊõ¥"ËßÑÊï¥" */
.heat-stress-content{
  display: grid;
  grid-template-columns: repeat(3, minmax(0, 1fr));
  gap: 18px;
  padding: 0 10px 10px;
  align-items: start;
}

/* ÊØè‰∏™ÊåáÊ†áÂùóÔºöÁî® flex ËÆ©ÂÜÖÈÉ®ÂØπÈΩê‰∏ÄËá¥ */
.heat-stress-item{
  text-align: center;
  display: flex;
  flex-direction: column;
  align-items: center;
}

/* ÂÖ≥ÈîÆÔºöÁªô label ‰∏Ä‰∏™ÊúÄÂ∞èÈ´òÂ∫¶ÔºåÈÅøÂÖçÊç¢Ë°åÂØºËá¥È´ò‰Ωé‰∏çÈΩê */
.heat-stress-label{
  min-height: 2.6em;            /* Á∫¶‰∏§Ë°åÈ´òÂ∫¶ */
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1.3;
  margin-bottom: 6px;
}

/* Êï∞ÂÄºÁöÑË°åÈ´ò/Èó¥Ë∑ùÁªü‰∏Ä */
.heat-stress-value{
  margin: 6px 0 8px;
  line-height: 1;
}

/* Â∫ïÈÉ®Âçï‰Ωç/ËØ¥Êòé‰πüÁªô‰∏™ÊúÄÂ∞èÈ´òÂ∫¶ÔºåËøõ‰∏ÄÊ≠•ÂØπÈΩê */
.heat-stress-item > div:last-child{
  min-height: 1.8em;
  line-height: 1.2;
}

/* ÂÖ≥ÈîÆÔºöËÆ© "Current Status" ÈÇ£‰∏ÄÂùóÊ®™Ë∑®Êï¥Ë°åÔºåÂ±Ö‰∏≠Â∞±‰∏ç‰ºö"ÂÅè‰∏ÄËæπ" */
#heatStressStatusItem,
#lightStatusItem{
  grid-column: 1 / -1;
  margin-top: 4px;
}

/* Áä∂ÊÄÅÊñáÂ≠óÂ§ßÂ∞èÁªü‰∏Ä‰∏ÄÁÇπÔºàË¶ÜÁõñ inline styleÔºâ */
#heatStressStatusItem .heat-stress-value,
#lightStatusItem .heat-stress-value{
  font-size: 1.7em !important;
}

/* Êé®ËçêÊ°ÜÂ∞ΩÈáèË¥¥Âà∞Â∫ïÈÉ®Ôºö‰∏§Âº†Âç°ÁöÑ Recommendation ‰ºöÊõ¥ÈΩê */
.heat-stress-recommendation{
  margin-top: auto;
}

/* Dashboard Âç°Ê†áÈ¢òÁªü‰∏ÄÈ´òÂ∫¶ÔºåÈÅøÂÖçÊç¢Ë°åÂØºËá¥È´ò‰Ωé‰∏çÂπ≥ */
.dashboard-card h3{
  min-height: 2.6em;
  display: flex;
  align-items: center;
  justify-content: center;
  line-height: 1.2;
}

/* Tabs right-side page nav buttons */
.tabs{
  display: flex;
  align-items: center;
  gap: 10px;
  flex-wrap: wrap;
}

.page-nav{
  margin-left: auto;
  display: inline-flex;
  gap: 8px;
  align-items: center;
}

.page-nav-btn{
  width: 34px;
  height: 34px;
  border-radius: 10px;
  border: 1px solid rgba(17,24,39,.14);
  background: rgba(255,255,255,.85);
  box-shadow: 0 6px 14px rgba(0,0,0,.08);
  cursor: pointer;
  font-size: 18px;
  line-height: 1;
  padding: 0;
}

.page-nav-btn:disabled{
  opacity: .4;
  cursor: not-allowed;
  box-shadow: none;
}

/* 24h charts: button switcher */
.history-switcher{ margin-top: 20px; }

.history-tabs{
  display: flex;
  gap: 10px;
  align-items: center;
  justify-content: center;
  flex-wrap: wrap;
  margin: 4px 0 14px;
}

.history-tab{
  padding: 8px 12px;
  border-radius: 999px;
  border: 1px solid rgba(17,24,39,.14);
  background: rgba(255,255,255,.70);
  box-shadow: 0 6px 14px rgba(0,0,0,.08);
  cursor: pointer;
  font-weight: 650;
  font-size: 0.95em;
}

.history-tab.active{
  background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
  color: #fff;
  border-color: rgba(79,70,229,.35);
}

.history-panel{ display: none; width: 100%; }
.history-panel.active{ display: block; }

</style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üå± Smart Planting Shelf IoT Dashboard</h1>
            <p>Real-time monitoring and control of greenhouse environment</p>
        </div>

        <!-- Tab Navigation -->
        <div class="tabs">
            <button class="tab-btn active" data-page="dashboard">Dashboard</button>
            <button class="tab-btn" data-page="trends">Trends & Analysis</button>
            <button class="tab-btn" data-page="events">Events & Actions</button>
            <button class="tab-btn" data-page="logs">Connection Logs</button>

            <!-- NEW: small left/right navigation buttons -->
            <div class="page-nav">
                <button id="prevPageBtn" class="page-nav-btn" type="button" aria-label="Previous page">‚Äπ</button>
                <button id="nextPageBtn" class="page-nav-btn" type="button" aria-label="Next page">‚Ä∫</button>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <span class="status-dot disconnected" id="mqttStatus"></span>
                <span id="mqttStatusText">Disconnected</span>
            </div>
        </div>

        <div class="content">
            <!-- Dashboard Page -->
            <section id="dashboard-page" class="page active">
                <div class="dashboard-grid">
                    <!-- Temperature Card -->
                    <div class="dashboard-card">
                        <h3>üå°Ô∏è Current Temperature</h3>
                        <div>
                            <span class="dashboard-value" id="dashboardTemperature">--</span>
                            <span class="dashboard-unit">¬∞C</span>
                        </div>
                    </div>
                    
                    <!-- Humidity Card -->
                    <div class="dashboard-card">
                        <h3>üíß Current Humidity</h3>
                        <div>
                            <span class="dashboard-value" id="dashboardHumidity">--</span>
                            <span class="dashboard-unit">%</span>
                        </div>
                    </div>
                    
                    <!-- Light Card -->
                    <div class="dashboard-card">
                        <h3>‚òÄÔ∏è Current Light</h3>
                        <div>
                            <span class="dashboard-value" id="dashboardLight">--</span>
                            <span class="dashboard-unit">%</span>
                        </div>
                    </div>
                    
                    <!-- Air Quality Card -->
                    <div class="dashboard-card">
                        <h3>üå¨Ô∏è Air Quality</h3>
                        <div>
                            <span class="dashboard-value" id="dashboardAirQuality">--</span>
                        </div>
                        <div style="margin-top: 15px;">
                            <span class="status-indicator offline" id="dashboardAirQualityBadge">Good</span>
                        </div>
                    </div>
                    
                </div>
            </section>

            <!-- Trends Page: Trends & Analysis -->
            <section id="trends-page" class="page">
            <!-- Sensor Status Cards -->
            <div class="trends-analysis-grid">
                <!-- Heat Stress Analysis Card -->
                <div class="sensor-card heat-stress-card" id="heatStressCard">
                    <div class="sensor-title" style="text-align: center; margin-bottom: 20px; font-size: 1.3em; color: #dc3545;">
                        üî• Heat Stress Analysis
                    </div>
                    <div class="heat-stress-content">
                        <div class="heat-stress-item" id="heatStressTemperatureItem">
                            <div class="heat-stress-label">Current Temperature</div>
                            <div class="heat-stress-value" id="heatStressTemperature" style="color: #dc3545;">--</div>
                            <div style="font-size: 0.85em; color: #6c757d;">Temperature (¬∞C)</div>
                            </div>
                        <div class="heat-stress-item" id="heatStressHumidityItem">
                            <div class="heat-stress-label">Current Humidity</div>
                            <div class="heat-stress-value" id="heatStressHumidity" style="color: #dc3545;">--</div>
                            <div style="font-size: 0.85em; color: #6c757d;">Humidity (%)</div>
                            </div>
                        <div class="heat-stress-item" id="heatStressDurationItem">
                            <div class="heat-stress-label">Heat Stress Duration (Last 2 Hours)</div>
                            <div class="heat-stress-value" id="heatStressDuration">0</div>
                            <div style="font-size: 0.85em; color: #6c757d;">Minutes</div>
                        </div>
                        <div class="heat-stress-item" id="heatStressStatusItem">
                            <div class="heat-stress-label">Current Status</div>
                            <div class="heat-stress-value" id="heatStressStatus" style="font-size: 1.5em;">--</div>
                            <div style="font-size: 0.85em; color: #6c757d;" id="heatStressLevel">--</div>
                            </div>
                            </div>
                    <div class="heat-stress-recommendation" id="heatStressRecommendation">
                        <div style="font-weight: 600; margin-bottom: 5px; color: #495057;">
                            üí° Recommendation
                            </div>
                        <div id="heatStressRecommendationText" style="color: #495057;">
                            Waiting for data...
                        </div>
                        <button class="why-button" id="whyButton" onclick="toggleWhyExplanation()">
                            Why?
                        </button>
                        <div class="why-explanation" id="whyExplanation">
                            <strong>Explanation:</strong><br>
                            <span id="whyExplanationText">--</span>
                            </div>
                            </div>
                            </div>

                <!-- Light Accumulation Analysis Card -->
                <div class="sensor-card light-accumulation-card" id="lightAccumulationCard">
                    <div class="sensor-title" style="text-align: center; margin-bottom: 20px; font-size: 1.3em; color: #ffc107;">
                        ‚òÄÔ∏è Light Accumulation Analysis
                        </div>
                    <div class="heat-stress-content">
                        <div class="heat-stress-item" id="lightRealTimeItem">
                            <div class="heat-stress-label">Real-time Light Intensity</div>
                            <div class="heat-stress-value" id="lightRealTimeIntensity" style="color: #ffc107; font-size: 2em;">--</div>
                            <div style="font-size: 0.85em; color: #6c757d;">Brightness (%)</div>
                        </div>
                        <div class="heat-stress-item" id="lightAccumulationItem">
                            <div class="heat-stress-label">Today's Accumulated Light</div>
                            <div class="heat-stress-value" id="lightAccumulationValue" style="color: #ffc107;">0</div>
                            <div style="font-size: 0.85em; color: #6c757d;">DLI-lite (relative value)</div>
                        </div>
                        <div class="heat-stress-item" id="lightTargetItem">
                            <div class="heat-stress-label">Target Progress</div>
                            <div class="heat-stress-value" id="lightTargetProgress" style="color: #ffc107;">0%</div>
                            <div style="font-size: 0.85em; color: #6c757d;">Target: <span id="lightTargetValue">1000</span> DLI-lite</div>
                        </div>
                        <div class="heat-stress-item" id="lightStatusItem">
                            <div class="heat-stress-label">Current Status</div>
                            <div class="heat-stress-value" id="lightAccumulationStatus" style="font-size: 1.5em;">--</div>
                            <div style="font-size: 0.85em; color: #6c757d;" id="lightAccumulationLevel">--</div>
                        </div>
                    </div>
                    <div class="heat-stress-recommendation" id="lightAccumulationRecommendation">
                        <div style="font-weight: 600; margin-bottom: 5px; color: #495057;">
                            üí° Recommendation
                        </div>
                        <div id="lightAccumulationRecommendationText" style="color: #495057;">
                            Waiting for data...
                        </div>
                        <button class="why-button" id="whyLightButton" onclick="toggleWhyLightExplanation()">
                            Why?
                        </button>
                        <div class="why-explanation" id="whyLightExplanation">
                            <strong>Explanation:</strong><br>
                            <span id="whyLightExplanationText">--</span>
                        </div>
                    </div>
                    </div>
                </div>

            <!-- 24 Hours History Charts (Temperature, Humidity, Light) -->
            <div class="history-switcher">
                <div class="history-tabs">
                    <button type="button" class="history-tab active" data-panel="chart24hTemp">Temperature</button>
                    <button type="button" class="history-tab" data-panel="chart24hHum">Humidity</button>
                    <button type="button" class="history-tab" data-panel="chart24hLight">Light</button>
                </div>

                <div class="history-panels">
                    <!-- Temperature -->
                    <div class="chart-container history-panel active" id="chart24hTemp">
                        <div class="chart-title">Temperature History Trend (24 hours)</div>
                        <canvas id="temperatureChart"></canvas>
                    </div>

                    <!-- Humidity -->
                    <div class="chart-container history-panel" id="chart24hHum">
                        <div class="chart-title">Humidity History Trend (24 hours)</div>
                        <canvas id="humidityChart"></canvas>
                    </div>

                    <!-- Light -->
                    <div class="chart-container history-panel" id="chart24hLight">
                        <div class="chart-title">Light Brightness History Trend (24 hours)</div>
                        <canvas id="lightChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Real-time Charts (Temperature and Humidity) -->
            <div style="display: flex; gap: 20px; margin-top: 20px;">
                <!-- Real-time Temperature Chart -->
                <div class="chart-container" style="flex: 1;">
                    <div class="chart-title">Real-time Temperature Trend</div>
                    <canvas id="realtimeTemperatureChart"></canvas>
                </div>
                
                <!-- Real-time Humidity Chart -->
                <div class="chart-container" style="flex: 1;">
                    <div class="chart-title">Real-time Humidity Trend</div>
                    <canvas id="realtimeHumidityChart"></canvas>
                </div>
            </div>

            </section>

            <!-- Events Page: Events & Actions -->
            <section id="events-page" class="page">
                <h2 style="margin-bottom: 20px; color: #333;">üìã Events & Actions Log</h2>
                
                <!-- Action Control Cards -->
                <div class="sensors-grid" style="margin-bottom: 30px;">
                <!-- RGB LED Control -->
                <div class="sensor-card" id="rgbLedCard">
                    <div class="sensor-icon">üåà</div>
                    <div class="sensor-title">RGB LED Control</div>
                    <div class="sensor-value" id="rgbLedCount">--</div>
                    <div style="text-align: center; margin-top: 10px; color: #6c757d; font-size: 0.9em;">
                            <div>Actual: <span id="rgbLedStatus">--</span></div>
                            <div style="margin-top: 5px;">Target: <span id="rgbLedTarget">--</span> <span id="rgbLedPending" style="color: #ffc107; font-weight: 600; display: none;">[Pending...]</span></div>
                    </div>
                        
                        <!-- Mode Tabs -->
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                            <div style="display: flex; gap: 5px; margin-bottom: 15px; border-bottom: 2px solid #dee2e6;">
                                <button id="rgbManualTabBtn" class="rgb-mode-tab active" data-mode="manual">
                                    Manual Control
                                </button>
                                <button id="rgbAutoTabBtn" class="rgb-mode-tab" data-mode="auto">
                                    Auto Control
                                </button>
                            </div>
                            
                            <!-- Manual Control Panel -->
                            <div id="rgbManualPanel" class="rgb-mode-panel active">
                        <div style="margin-bottom: 10px;">
                                    <label for="rgbLedSlider" style="display: block; margin-bottom: 5px; font-size: 0.9em; color: #495057; font-weight: 600;">
                                        Manual LED Count: <span id="rgbLedSliderValue">0</span>/5
                            </label>
                            <input type="range" id="rgbLedSlider" min="0" max="5" value="0" step="1" 
                                   style="width: 100%; height: 8px; border-radius: 5px; background: #e9ecef; outline: none; cursor: pointer;">
                        </div>
                        <div style="display: flex; gap: 5px; margin-bottom: 10px;">
                                    <button id="rgbLedSetBtn" style="flex: 1; padding: 10px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.95em; font-weight: 600;">
                                        Set
                            </button>
                                    <button id="rgbLedAutoBtn" style="flex: 1; padding: 10px; background: #28a745; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.95em; font-weight: 600;">
                                        Switch to Auto
                            </button>
                        </div>
                                <div style="text-align: center; font-size: 0.85em; color: #6c757d; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">Current Mode: <span id="rgbControlMode" style="color: #667eea;">Manual Mode</span></div>
                                    <div style="font-size: 0.8em;">In manual mode, the system will not automatically adjust LED count</div>
                    </div>
                </div>

                            <!-- Auto Control Panel -->
                            <div id="rgbAutoPanel" class="rgb-mode-panel">
                                <div style="text-align: center; padding: 15px; background: #e8f5e9; border-radius: 5px; margin-bottom: 15px;">
                                    <div style="font-size: 1.1em; font-weight: 600; color: #28a745; margin-bottom: 5px;">
                                        ü§ñ Auto Control Mode
                    </div>
                                    <div style="font-size: 0.85em; color: #495057;">
                                        System will automatically adjust LED count based on light accumulation analysis
                            </div>
                        </div>
                                <div style="margin-bottom: 10px;">
                                    <div style="font-size: 0.9em; color: #495057; font-weight: 600; margin-bottom: 8px;">
                                        Auto Control Logic:
                            </div>
                                    <div style="font-size: 0.85em; color: #6c757d; line-height: 1.6; padding: 10px; background: #f8f9fa; border-radius: 5px;">
                                        ‚Ä¢ System monitors daily light accumulation (DLI-lite)<br>
                                        ‚Ä¢ Automatically turns on supplemental light when insufficient<br>
                                        ‚Ä¢ Adjusts LED count (3-5) based on light requirements<br>
                                        ‚Ä¢ Automatically turns off supplemental light when sufficient
                        </div>
                            </div>
                                <div style="display: flex; gap: 5px;">
                                    <button id="rgbLedManualBtn" style="flex: 1; padding: 10px; background: #667eea; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.95em; font-weight: 600;">
                                        Switch to Manual
                                    </button>
                            </div>
                                <div style="text-align: center; font-size: 0.85em; color: #6c757d; padding: 10px; background: #f8f9fa; border-radius: 5px; margin-top: 10px;">
                                    <div style="font-weight: 600; margin-bottom: 5px;">Current Mode: <span id="rgbAutoControlMode" style="color: #28a745;">Auto Mode</span></div>
                                    <div style="font-size: 0.8em;">System is intelligently controlling LEDs, no manual intervention needed</div>
                        </div>
                    </div>
                    </div>
                </div>

                <!-- Fan Control -->
                <div class="sensor-card" id="fanCard">
                    <div class="sensor-icon">üåÄ</div>
                    <div class="sensor-title">Ventilation System (Fan)</div>
                    <div class="sensor-value" id="fanStatus">--</div>
                    <div style="text-align: center;">
                        <span class="sensor-status off" id="fanStatusBadge">OFF</span>
                    </div>
                    <div style="text-align: center; margin-top: 10px; color: #6c757d; font-size: 0.85em;">
                        <span id="fanMode">Mode: Auto</span>
                    </div>
                    <!-- Temperature Threshold Control -->
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #dee2e6;">
                            <div style="margin-bottom: 15px;">
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                    <label for="tempThresholdSlider" style="font-size: 0.95em; color: #495057; font-weight: 600; display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 1.2em;">üå°Ô∏è</span>
                                        <span>Temperature Threshold</span>
                            </label>
                                    <div style="font-size: 1.3em; font-weight: bold; color: #667eea; padding: 5px 12px; background: linear-gradient(135deg, #e8f0ff 0%, #d0e0ff 100%); border-radius: 8px;">
                                        <span id="tempThresholdDisplay">25.0</span><span style="font-size: 0.7em; margin-left: 2px;">¬∞C</span>
                            </div>
                            </div>
                                
                                <!-- Slider with visual indicator -->
                                <div style="position: relative; margin-bottom: 15px;">
                                    <input type="range" id="tempThresholdSlider" min="25" max="50" step="0.1" value="25.0" 
                                           style="width: 100%; height: 10px; border-radius: 5px; background: linear-gradient(to right, #4CAF50 0%, #FFC107 50%, #FF5722 100%); outline: none; cursor: pointer; -webkit-appearance: none; appearance: none;">
                                    <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.75em; color: #6c757d;">
                                        <span>25¬∞C</span>
                                        <span style="font-weight: 600; color: #495057;">Recommended: 28-32¬∞C</span>
                                        <span>50¬∞C</span>
                            </div>
                        </div>
                                
                                <!-- Quick preset buttons -->
                                <div style="margin-bottom: 12px;">
                                    <div style="font-size: 0.8em; color: #6c757d; margin-bottom: 6px; font-weight: 600;">Quick Presets:</div>
                                    <div style="display: flex; gap: 5px; flex-wrap: wrap;">
                                        <button type="button" class="temp-preset-btn" data-value="25">25¬∞C</button>
                                        <button type="button" class="temp-preset-btn" data-value="28">28¬∞C</button>
                                        <button type="button" class="temp-preset-btn" data-value="30">30¬∞C</button>
                                        <button type="button" class="temp-preset-btn" data-value="32">32¬∞C</button>
                                        <button type="button" class="temp-preset-btn" data-value="35">35¬∞C</button>
                </div>
            </div>

                                <!-- Current threshold display with comparison -->
                                <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 8px; padding: 12px; margin-bottom: 10px;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                                        <span style="font-size: 0.85em; color: #6c757d; font-weight: 600;">Current Threshold:</span>
                                        <span id="currentTempThreshold" style="font-size: 1.1em; font-weight: bold; color: #667eea;">25.0¬∞C</span>
            </div>
                                    <div id="tempThresholdComparison" style="font-size: 0.8em; color: #6c757d; text-align: center; padding-top: 8px; border-top: 1px solid #dee2e6;">
                                        Waiting for temperature data...
                                    </div>
            </div>

                                <!-- Set button -->
                                <button type="button" id="tempThresholdSetBtn" style="width: 100%; padding: 12px; background: linear-gradient(135deg, #667eea 0%, #5568d3 100%); color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 1em; font-weight: 600; box-shadow: 0 2px 4px rgba(102, 126, 234, 0.3); transition: all 0.3s;">
                                    ‚úì Apply Settings
                                </button>
                            </div>
                        </div>
                </div>
                
                    <!-- Alert Information -->
                    <div class="alert-section sensor-card" id="alertSection">
                        <div class="sensor-icon">üö®</div>
                        <div class="sensor-title">Alert Information</div>
                        <div class="alert-list" id="alertList" style="margin-top: 15px;">
                            <div style="text-align: center; padding: 20px; color: #6c757d; font-style: italic;">
                                No alerts
                            </div>
                        </div>
                </div>
            </div>

                <!-- Events List -->
                <div class="events-list" id="eventsList">
                    <div style="text-align: center; padding: 40px; color: #6c757d;">
                        Waiting for event records...
            </div>
                </div>
            </section>

            <!-- Logs Page: Connection Logs -->
            <section id="logs-page" class="page">
                <h2 style="margin-bottom: 20px; color: #333;">üì° Connection Logs</h2>
                
                <!-- Connection Log -->
                <div class="message-log">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h3 style="margin: 0; border-bottom: none; padding: 0;">MQTT Connection Log</h3>
                        <button id="clearLogBtn" style="padding: 5px 15px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 0.85em; transition: background 0.3s;" onmouseover="this.style.background='#c82333'" onmouseout="this.style.background='#dc3545'">
                            Clear Log
                        </button>
                    </div>
                    <div id="logContainer"></div>
                </div>
            </section>
        </div>
    </div>

    <script>
        // MQTT configuration (will be loaded from YAML)
        let MQTT_CONFIG = null;

        // Load configuration from YAML file
        async function loadConfig() {
            try {
                const response = await fetch('web_config.yaml');
                if (!response.ok) {
                    throw new Error(`Failed to load config: ${response.statusText}`);
                }
                const yamlText = await response.text();
                const config = jsyaml.load(yamlText);
                
                // Convert YAML config to MQTT_CONFIG format
                MQTT_CONFIG = {
                    host: config.mqtt.host,
                    topicSensor: config.mqtt.topics.sensor,
                    topicAlert: config.mqtt.topics.alert,
                    topicControl: config.mqtt.topics.control,
                    topicHistory: config.mqtt.topics.history || 'demo/esp32-1/history24h',
                    topicHistoryRequest: config.mqtt.topics.history_request || 'demo/esp32-1/history24h/request',
                    options: {
                        clientId: config.mqtt.client.client_id_prefix + Math.random().toString(16).substr(2, 8),
                        username: config.mqtt.authentication.username,
                        password: config.mqtt.authentication.password,
                        clean: config.mqtt.client.clean,
                        reconnectPeriod: config.mqtt.client.reconnect_period
                    }
                };
                
                console.log('Configuration loaded successfully');
                return true;
            } catch (error) {
                console.error('Failed to load configuration:', error);
                addLog(`Configuration load error: ${error.message}`, 'error');
                // Use default configuration as fallback
                MQTT_CONFIG = {
                    host: 'wss://lca0944f.ala.cn-hangzhou.emqxsl.cn:8084/mqtt',
                    topicSensor: '/public/esp32/smart_home',
                    topicAlert: '/public/esp32/smart_home/alert',
                    topicControl: '/public/esp32/smart_home/control',
                    topicHistory: 'demo/esp32-1/history24h',
                    topicHistoryRequest: 'demo/esp32-1/history24h/request',
                    options: {
                        clientId: 'esp32-smart-home-web-' + Math.random().toString(16).substr(2, 8),
                        username: 'ESP32_Binkle',
                        password: '1234',
                        clean: true,
                        reconnectPeriod: 5000
                    }
                };
                addLog('Using default configuration', 'info');
                return false;
            }
        }

        // State variables
        let mqttClient = null;
        let messageCount = 0;
        let temperatureChart = null;  // 24Â∞èÊó∂ÂéÜÂè≤Ê∏©Â∫¶ÂõæË°®
        let realtimeTemperatureChart = null;  // ÂÆûÊó∂Ê∏©Â∫¶ÂõæË°®
        let humidityChart = null;  // 24Â∞èÊó∂ÂéÜÂè≤ÊπøÂ∫¶ÂõæË°®
        let realtimeHumidityChart = null;  // ÂÆûÊó∂ÊπøÂ∫¶ÂõæË°®
        let startTime = Date.now();
        let alertCount = 0;
        let isManualMode = false;  // Whether in manual control mode
        let tempThresholdJustUpdated = false;  // Flag to track if threshold was just updated by user
        let historyLoaded = false;  // Flag to track if history data has been loaded
        let lastHistoryT0 = null;  // Track last processed history data timestamp to avoid duplicate processing
        let targetLedCount = null;  // Target LED count set by user (manual mode)
        let targetLedSetTime = null;  // Timestamp when target was set (for timeout detection)
        let historyDataPointCount = 144;  // Actual number of history data points from bridge (default: 144, 10 minutes per interval)
        
        // Heat Stress Analysis Variables
        const HEAT_STRESS_WINDOW_MS = 2 * 60 * 60 * 1000;  // 2 hours in milliseconds
        const DATA_INTERVAL_MS = 600 * 1000;  // 10 minutes data interval (matching bridge sampling rate)
        let heatStressHistory = [];  // Array of {timestamp, temp, humidity, isStress}
        let heatStressZones = [];  // Array of {start, end} for chart annotation
        
        // Light Accumulation Analysis Variables
        const LIGHT_TARGET_DLI = 1000;  // ÁõÆÊ†áÊó•Á¥ØËÆ°ÂÖâÁÖßÂÄºÔºàDLI-liteÔºåÁõ∏ÂØπÂÄºÔºâ
        const LIGHT_DATA_INTERVAL_MS = 600 * 1000;  // 10 minutes data interval (matching bridge sampling rate)
        let lightHistory = [];  // Array of {timestamp, brightness, dli}
        let todayLightAccumulation = 0;  // ‰ªäÊó•Á¥ØËÆ°ÂÖâÁÖßÂÄº
        let todayStartTime = null;  // ‰ªäÊó•0ÁÇπÁöÑÊó∂Èó¥Êà≥
        let lightChart = null;  // 24Â∞èÊó∂ÂÖâÁÖßÂéÜÂè≤ÂõæË°®
        
        // Events and Actions Log
        let eventsLog = [];  // Array of {timestamp, type, message, snapshot, actionType}
        let lastEventState = {
            heatStress: false,
            lowLight: false,
            supplementalLightOn: false,
            fanOn: false,
            airQualityPoor: false  // Á©∫Ê∞îË¥®ÈáèÂ∑ÆÁä∂ÊÄÅË∑üË∏™
        };
        
        // Track air quality alert for auto-removal
        let airQualityAlertInfo = {
            alertItem: null,  // DOM element of the alert
            timestamp: null,  // Timestamp when alert was created
            removalTimer: null  // Timer for delayed removal
        };
        
        // Track temperature alert for auto-removal
        let temperatureAlertInfo = {
            alertItem: null,  // DOM element of the alert
            timestamp: null,  // Timestamp when alert was created
            removalTimer: null  // Timer for delayed removal
        };
        
        // Check if heat stress conditions are met
        // Heat stress is determined by combining temperature and humidity thresholds
        function isHeatStressCondition(temperature, humidity) {
            if (temperature === null || humidity === null || isNaN(temperature) || isNaN(humidity)) {
                return false;
            }
            
            // Heat stress occurs when:
            // 1. Temperature > 28¬∞C with humidity > 75%, OR
            // 2. Temperature > 30¬∞C regardless of humidity
            return (temperature > 28 && humidity > 75) || temperature > 30;
        }
        
        // Update heat stress history and calculate duration
        function updateHeatStressHistory(temperature, humidity) {
            const now = Date.now();
            
            // Add current data point
            const isStress = isHeatStressCondition(temperature, humidity);
            
            heatStressHistory.push({
                timestamp: now,
                temperature: temperature,
                humidity: humidity,
                isStress: isStress
            });
            
            // Remove data older than 2 hours
            const cutoffTime = now - HEAT_STRESS_WINDOW_MS;
            heatStressHistory = heatStressHistory.filter(item => item.timestamp >= cutoffTime);
            
            // Calculate total stress duration in minutes
            let stressDurationMinutes = 0;
            let inStressPeriod = false;
            let stressStartTime = null;
            
            for (let i = 0; i < heatStressHistory.length; i++) {
                const item = heatStressHistory[i];
                
                if (item.isStress && !inStressPeriod) {
                    // Start of stress period
                    inStressPeriod = true;
                    stressStartTime = item.timestamp;
                } else if (!item.isStress && inStressPeriod) {
                    // End of stress period
                    if (stressStartTime !== null) {
                        const duration = item.timestamp - stressStartTime;
                        stressDurationMinutes += Math.ceil(duration / (60 * 1000));  // Convert to minutes
                    }
                    inStressPeriod = false;
                    stressStartTime = null;
                }
            }
            
            // If still in stress period, add time from start to now
            if (inStressPeriod && stressStartTime !== null) {
                const duration = now - stressStartTime;
                stressDurationMinutes += Math.ceil(duration / (60 * 1000));
            }
            
            return {
                duration: stressDurationMinutes,
                isStress: isStress,
                temperature: temperature,
                humidity: humidity
            };
        }
        
        // Get heat stress recommendation
        function getHeatStressRecommendation(duration, isStress, temperature, humidity) {
            if (temperature === null || humidity === null) {
                return {
                    text: 'Waiting for data...',
                    level: 'safe',
                    explanation: 'System is collecting temperature and humidity data, please wait.'
                };
            }
            
            if (!isStress) {
                return {
                    text: 'Environmental conditions are good, no action needed.',
                    level: 'safe',
                    explanation: `Current temperature ${temperature.toFixed(1)}¬∞C, humidity ${humidity.toFixed(1)}%, heat stress conditions not met. No heat stress recorded in the past 2 hours.`
                };
            }
            
            if (duration >= 30) {
                return {
                    text: '‚ö†Ô∏è Recommend immediately turning on ventilation for at least 10 minutes to reduce temperature and humidity.',
                    level: 'high',
                    explanation: `Heat stress has persisted for ${duration} minutes in the past 2 hours. Current temperature ${temperature.toFixed(1)}¬∞C, humidity ${humidity.toFixed(1)}%, heat stress conditions met (temperature>28¬∞C and humidity>75%, or temperature>30¬∞C). Prolonged high temperature and humidity can damage crops, recommend immediate cooling measures.`
                };
            } else if (duration >= 15) {
                return {
                    text: 'Recommend turning on ventilation to improve environmental conditions.',
                    level: 'moderate',
                    explanation: `Heat stress has persisted for ${duration} minutes in the past 2 hours. Current temperature ${temperature.toFixed(1)}¬∞C, humidity ${humidity.toFixed(1)}%, heat stress conditions met. Recommend turning on ventilation to reduce temperature and humidity.`
                };
            } else {
                return {
                    text: 'Monitoring, if heat stress persists for more than 15 minutes, ventilation will be recommended.',
                    level: 'moderate',
                    explanation: `Current temperature ${temperature.toFixed(1)}¬∞C, humidity ${humidity.toFixed(1)}%, heat stress conditions met. Heat stress has persisted for ${duration} minutes in the past 2 hours. System will continue monitoring, if duration exceeds 15 minutes, action will be recommended.`
                };
            }
        }
        
        // Update heat stress display
        function updateHeatStressDisplay(temperature, humidity) {
            const analysis = updateHeatStressHistory(temperature, humidity);
            const recommendation = getHeatStressRecommendation(analysis.duration, analysis.isStress, analysis.temperature, analysis.humidity);
            
            // Check if heat stress condition changed
            const currentHeatStress = analysis.isStress;
            
            // If heat stress detected and wasn't detected before, log event
            if (currentHeatStress && !lastEventState.heatStress) {
                addEventLog('heat_stress_condition', {
                    message: `Heat stress risk detected. Temperature: ${temperature.toFixed(1)}¬∞C, Humidity: ${humidity.toFixed(1)}%, Heat stress duration in past 2 hours: ${analysis.duration} minutes.`,
                    snapshot: {
                        temp: temperature,
                        rh: humidity
                    }
                });
                
                // Suggest fan action (fan is controlled by temperature threshold, so we just log)
                if (analysis.duration >= 15) {
                    triggerAction('fan_on');
                }
                lastEventState.heatStress = true;
            } else if (!currentHeatStress && lastEventState.heatStress) {
                // Heat stress condition improved
                triggerAction('fan_off');
                lastEventState.heatStress = false;
            }
            
            // Update temperature display (separate item)
            const temperatureElement = document.getElementById('heatStressTemperature');
            if (temperatureElement) {
                temperatureElement.textContent = analysis.temperature !== null ? analysis.temperature.toFixed(1) + '¬∞C' : '--';
            }
            
            // Update humidity display (separate item)
            const humidityElement = document.getElementById('heatStressHumidity');
            if (humidityElement) {
                humidityElement.textContent = analysis.humidity !== null ? analysis.humidity.toFixed(1) + '%' : '--';
            }
            
            // Update duration display
            const durationElement = document.getElementById('heatStressDuration');
            if (durationElement) {
                durationElement.textContent = analysis.duration;
            }
            
            // Update status
            const statusElement = document.getElementById('heatStressStatus');
            const levelElement = document.getElementById('heatStressLevel');
            if (statusElement && levelElement) {
                if (analysis.isStress) {
                    statusElement.textContent = '‚ö†Ô∏è Heat Stress';
                    levelElement.textContent = 'Heat Stress Detected';
                } else {
                    statusElement.textContent = '‚úì Normal';
                    levelElement.textContent = 'Normal';
                }
            }
            
            // Update recommendation
            const recommendationText = document.getElementById('heatStressRecommendationText');
            const recommendationDiv = document.getElementById('heatStressRecommendation');
            const whyExplanationText = document.getElementById('whyExplanationText');
            
            if (recommendationText) {
                recommendationText.textContent = recommendation.text;
            }
            if (whyExplanationText) {
                whyExplanationText.textContent = recommendation.explanation;
            }
            
            // Update card styling based on level
            const card = document.getElementById('heatStressCard');
            const temperatureItem = document.getElementById('heatStressTemperatureItem');
            const humidityItem = document.getElementById('heatStressHumidityItem');
            const durationItem = document.getElementById('heatStressDurationItem');
            const statusItem = document.getElementById('heatStressStatusItem');
            
            if (card) {
                card.className = 'sensor-card heat-stress-card ' + recommendation.level;
            }
            if (recommendationDiv) {
                recommendationDiv.className = 'heat-stress-recommendation ' + recommendation.level;
            }
            if (temperatureItem) {
                temperatureItem.className = 'heat-stress-item ' + recommendation.level;
            }
            if (humidityItem) {
                humidityItem.className = 'heat-stress-item ' + recommendation.level;
            }
            if (durationItem) {
                durationItem.className = 'heat-stress-item ' + recommendation.level;
            }
            if (statusItem) {
                statusItem.className = 'heat-stress-item ' + recommendation.level;
            }
        }
        
        // Toggle why explanation
        function toggleWhyExplanation() {
            const explanation = document.getElementById('whyExplanation');
            if (explanation) {
                explanation.classList.toggle('show');
            }
        }

        // Toggle why light explanation
        function toggleWhyLightExplanation() {
            const explanation = document.getElementById('whyLightExplanation');
            if (explanation) {
                explanation.classList.toggle('show');
            }
        }

        // Tab Navigation Functions
        function initTabNavigation() {
            const tabButtons = document.querySelectorAll('.tab-btn');
            const pages = document.querySelectorAll('.page');
            
            tabButtons.forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetPage = btn.getAttribute('data-page');
                    
                    // Remove active class from all buttons and pages
                    tabButtons.forEach(b => b.classList.remove('active'));
                    pages.forEach(p => p.classList.remove('active'));
                    
                    // Add active class to clicked button and corresponding page
                    btn.classList.add('active');
                    const targetPageElement = document.getElementById(`${targetPage}-page`);
                    if (targetPageElement) {
                        targetPageElement.classList.add('active');
                    }
                });
            });
        }

        // Initialize arrow page navigation buttons
        function initArrowPageNav() {
            const tabButtons = Array.from(document.querySelectorAll('.tab-btn'));
            const prevBtn = document.getElementById('prevPageBtn');
            const nextBtn = document.getElementById('nextPageBtn');
            if (!prevBtn || !nextBtn || tabButtons.length < 2) return;

            const getActiveIndex = () => tabButtons.findIndex(b => b.classList.contains('active'));

            const updateDisabled = () => {
                const i = getActiveIndex();
                prevBtn.disabled = i <= 0;
                nextBtn.disabled = i >= tabButtons.length - 1;
            };

            prevBtn.addEventListener('click', () => {
                const i = getActiveIndex();
                if (i > 0) tabButtons[i - 1].click();
            });

            nextBtn.addEventListener('click', () => {
                const i = getActiveIndex();
                if (i < tabButtons.length - 1) tabButtons[i + 1].click();
            });

            // ÂΩìÁî®Êà∑ÁÇπ tab Êó∂ÔºåÂêåÊ≠•Á¶ÅÁî®Áä∂ÊÄÅ
            tabButtons.forEach(btn => btn.addEventListener('click', updateDisabled));

            updateDisabled();
        }
        
        // RGB LED Mode Tab Navigation
        function initRGBModeTabs() {
            const manualTabBtn = document.getElementById('rgbManualTabBtn');
            const autoTabBtn = document.getElementById('rgbAutoTabBtn');
            const manualPanel = document.getElementById('rgbManualPanel');
            const autoPanel = document.getElementById('rgbAutoPanel');
            
            if (!manualTabBtn || !autoTabBtn || !manualPanel || !autoPanel) {
                console.warn('RGB mode tab elements not found');
                return;
            }
            
            // Manual tab click
            manualTabBtn.addEventListener('click', () => {
                manualTabBtn.classList.add('active');
                autoTabBtn.classList.remove('active');
                manualPanel.classList.add('active');
                autoPanel.classList.remove('active');
            });
            
            // Auto tab click
            autoTabBtn.addEventListener('click', () => {
                autoTabBtn.classList.add('active');
                manualTabBtn.classList.remove('active');
                autoPanel.classList.add('active');
                manualPanel.classList.remove('active');
            });
            
            // Initialize based on current mode
            if (isManualMode) {
                manualTabBtn.classList.add('active');
                autoTabBtn.classList.remove('active');
                manualPanel.classList.add('active');
                autoPanel.classList.remove('active');
            } else {
                autoTabBtn.classList.add('active');
                manualTabBtn.classList.remove('active');
                autoPanel.classList.add('active');
                manualPanel.classList.remove('active');
            }
        }
        
        // Switch to manual mode tab
        function switchToManualTab() {
            const manualTabBtn = document.getElementById('rgbManualTabBtn');
            const autoTabBtn = document.getElementById('rgbAutoTabBtn');
            const manualPanel = document.getElementById('rgbManualPanel');
            const autoPanel = document.getElementById('rgbAutoPanel');
            
            if (manualTabBtn && autoTabBtn && manualPanel && autoPanel) {
                manualTabBtn.classList.add('active');
                autoTabBtn.classList.remove('active');
                manualPanel.classList.add('active');
                autoPanel.classList.remove('active');
            }
        }
        
        // Switch to auto mode tab
        function switchToAutoTab() {
            const manualTabBtn = document.getElementById('rgbManualTabBtn');
            const autoTabBtn = document.getElementById('rgbAutoTabBtn');
            const manualPanel = document.getElementById('rgbManualPanel');
            const autoPanel = document.getElementById('rgbAutoPanel');
            
            if (manualTabBtn && autoTabBtn && manualPanel && autoPanel) {
                autoTabBtn.classList.add('active');
                manualTabBtn.classList.remove('active');
                autoPanel.classList.add('active');
                manualPanel.classList.remove('active');
            }
        }

        // Add Event Log (‰∫ã‰ª∂ËÆ∞ÂΩï)
        function addEventLog(eventType, data) {
            const timestamp = Date.now();
            const event = {
                timestamp: timestamp,
                type: 'event',
                eventType: eventType,
                message: data.message || '',
                snapshot: data.snapshot || {}
            };
            
            eventsLog.unshift(event); // Add to beginning (newest first)
            
            // Keep only last 100 events
            if (eventsLog.length > 100) {
                eventsLog = eventsLog.slice(0, 100);
            }
            
            updateEventsDisplay();
            console.log('üìù Event logged:', event);
        }

        // Add Action Log (Âä®‰ΩúËÆ∞ÂΩï)
        function addActionLog(actionType, data) {
            const timestamp = Date.now();
            const action = {
                timestamp: timestamp,
                type: 'action',
                actionType: actionType,
                message: data.message || ''
            };
            
            eventsLog.unshift(action); // Add to beginning (newest first)
            
            // Keep only last 100 events
            if (eventsLog.length > 100) {
                eventsLog = eventsLog.slice(0, 100);
            }
            
            updateEventsDisplay();
            console.log('‚ö° Action logged:', action);
        }

        // Update Events Display
        function updateEventsDisplay() {
            const eventsList = document.getElementById('eventsList');
            if (!eventsList) return;
            
            if (eventsLog.length === 0) {
                eventsList.innerHTML = '<div style="text-align: center; padding: 40px; color: #6c757d;">Waiting for event records...</div>';
                return;
            }
            
            eventsList.innerHTML = eventsLog.map(item => {
                const timeStr = new Date(item.timestamp).toLocaleString('en-US');
                const typeClass = item.type === 'event' ? 'event' : (item.type === 'action' ? 'action' : 'alert');
                const typeLabel = item.type === 'event' ? 'Event' : (item.type === 'action' ? 'Action' : 'Alert');
                
                let snapshotHtml = '';
                if (item.snapshot && Object.keys(item.snapshot).length > 0) {
                    const snapshotStr = Object.entries(item.snapshot)
                        .map(([key, value]) => {
                            if (key === 'light') return `Light: ${value.toFixed(1)}%`;
                            if (key === 'temp') return `Temperature: ${value.toFixed(1)}¬∞C`;
                            if (key === 'rh') return `Humidity: ${value.toFixed(1)}%`;
                            return `${key}: ${value}`;
                        })
                        .join(', ');
                    snapshotHtml = `<div class="event-snapshot">üì∏ Snapshot: ${snapshotStr}</div>`;
                }
                
                return `
                    <div class="event-item ${typeClass}">
                        <div class="event-header">
                            <span class="event-time">${timeStr}</span>
                            <span class="event-type ${typeClass}">${typeLabel}</span>
                        </div>
                        <div class="event-message">${item.message}</div>
                        ${snapshotHtml}
                    </div>
                `;
            }).join('');
        }

        // Trigger Action (Ëß¶ÂèëÂä®‰Ωú)
        function triggerAction(actionType, params = {}) {
            // If in manual mode, prevent automatic light control actions
            if (isManualMode && (actionType === 'grow_light_on' || actionType === 'grow_light_off')) {
                console.log(`‚ö†Ô∏è Manual mode active, skipping automatic ${actionType === 'grow_light_on' ? 'turn on' : 'turn off'} supplemental light`);
                return;
            }
            
            if (!mqttClient || !mqttClient.connected) {
                console.warn('MQTT not connected, cannot trigger action:', actionType);
                return;
            }
            
            // Map action types to MQTT commands
            let command = {};
            let actionMessage = '';
            
            switch (actionType) {
                case 'grow_light_on':
                    // ÂºÄÂêØË°•ÂÖâÁÅØÔºà‰ΩøÁî®RGB LEDÊéßÂà∂Ôºâ
                    const lightMinutes = params.minutes || 30;
                    // Ê†πÊçÆË°•ÂÖâÂàÜÈíüÊï∞ÂêàÁêÜËÆ°ÁÆóLEDÊï∞ÈáèÔºö
                    // - 30ÂàÜÈíü‰ª•‰∏ãÔºö3‰∏™LED
                    // - 30-60ÂàÜÈíüÔºö4‰∏™LED
                    // - 60ÂàÜÈíü‰ª•‰∏äÔºö5‰∏™LED
                    let ledCount;
                    if (lightMinutes <= 30) {
                        ledCount = 3;
                    } else if (lightMinutes <= 60) {
                        ledCount = 4;
                    } else {
                        ledCount = 5;
                    }
                    command = { rgb_led_count: ledCount };
                    actionMessage = `System automatically turned on supplemental light (${ledCount} LEDs, expected runtime: ${lightMinutes} minutes)`;
                    console.log(`üí° Supplemental light calculation: ${lightMinutes} minutes needed, setting ${ledCount} LEDs`);
                    break;
                    
                case 'grow_light_off':
                    command = { rgb_led_count: 0 };
                    actionMessage = 'System automatically turned off supplemental light';
                    break;
                    
                case 'fan_on':
                    // Fan is automatically controlled by temperature threshold, just log event
                    actionMessage = 'System detected high temperature, ventilation fan will automatically turn on';
                    break;
                    
                case 'fan_off':
                    actionMessage = 'Temperature returned to normal, ventilation fan will automatically turn off';
                    break;
                    
                case 'fan_on_air_quality':
                    // Turn on fan when air quality is poor
                    command = { fan_control: "ON", reason: "air_quality" };
                    actionMessage = 'System detected poor air quality, ventilation fan turned on';
                    break;
                    
                case 'fan_off_air_quality':
                    // Turn off fan when air quality recovers
                    command = { fan_control: "OFF", reason: "air_quality" };
                    actionMessage = 'Air quality has recovered, ventilation fan turned off';
                    break;
                    
                default:
                    console.warn('Unknown action type:', actionType);
                    return;
            }
            
            // Publish MQTT command if available
            if (Object.keys(command).length > 0) {
                const message = JSON.stringify(command);
                mqttClient.publish(MQTT_CONFIG.topicControl, message, { qos: 1 }, (err) => {
                    if (err) {
                        console.error(`Failed to publish action ${actionType}:`, err);
                        addActionLog(actionType, { message: `‚ùå Action failed: ${actionMessage}` });
                    } else {
                        console.log(`‚úÖ Action ${actionType} triggered`);
                        addActionLog(actionType, { message: `‚úÖ ${actionMessage}` });
                    }
                });
            } else {
                // Just log the action without MQTT command
                addActionLog(actionType, { message: `‚ÑπÔ∏è ${actionMessage}` });
            }
        }

        // Get today's start time (00:00:00)
        function getTodayStartTime() {
            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            return today.getTime();
        }

        // Update today's start time if needed (when day changes)
        function updateTodayStartTime() {
            const currentTodayStart = getTodayStartTime();
            if (todayStartTime === null || currentTodayStart !== todayStartTime) {
                // Day changed, reset accumulation
                if (todayStartTime !== null) {
                    console.log('üìÖ Date changed, resetting light accumulation');
                }
                todayStartTime = currentTodayStart;
                todayLightAccumulation = 0;
                // Keep only today's data
                const now = Date.now();
                lightHistory = lightHistory.filter(item => item.timestamp >= todayStartTime);
            }
        }

        // Calculate DLI-lite from brightness percentage
        // DLI-lite is a simplified cumulative light index
        // Formula: DLI-lite = brightness_percentage * time_interval_minutes / 60
        // This gives a relative cumulative value
        function calculateDLI(brightness, intervalMinutes) {
            if (brightness === null || brightness === undefined || isNaN(brightness)) {
                return 0;
            }
            // DLI-lite = brightness% * interval_minutes / 60
            // This creates a cumulative index where 100% brightness for 1 hour = 100 DLI-lite
            return (brightness * intervalMinutes) / 60;
        }

        // Update light accumulation history
        function updateLightAccumulation(brightness) {
            const now = Date.now();
            updateTodayStartTime();
            
            if (brightness === null || brightness === undefined || isNaN(brightness)) {
                return {
                    accumulation: todayLightAccumulation,
                    targetProgress: 0,
                    brightness: null
                };
            }
            
            // Calculate DLI for this data point (using 10 minute interval, matching bridge sampling rate)
            const dli = calculateDLI(brightness, 10);
            
            // Add to history (only today's data)
            lightHistory.push({
                timestamp: now,
                brightness: brightness,
                dli: dli
            });
            
            // Remove data older than today
            lightHistory = lightHistory.filter(item => item.timestamp >= todayStartTime);
            
            // Recalculate today's accumulation from all today's data points
            todayLightAccumulation = lightHistory.reduce((sum, item) => sum + item.dli, 0);
            
            // Calculate target progress
            const targetProgress = (todayLightAccumulation / LIGHT_TARGET_DLI) * 100;
            
            return {
                accumulation: todayLightAccumulation,
                targetProgress: Math.min(100, Math.max(0, targetProgress)),
                brightness: brightness
            };
        }

        // Get light accumulation recommendation
        function getLightAccumulationRecommendation(accumulation, targetProgress, brightness) {
            if (brightness === null || brightness === undefined) {
                return {
                    text: 'Waiting for data...',
                    level: 'safe',
                    explanation: 'System is collecting light data, please wait.',
                    needSupplementalLight: false,
                    supplementalMinutes: 0
                };
            }
            
            const now = new Date();
            const hoursElapsed = (now.getTime() - todayStartTime) / (1000 * 60 * 60);
            const remainingHours = Math.max(0, 24 - hoursElapsed);
            
            // Calculate expected final accumulation if current rate continues
            const currentRate = hoursElapsed > 0 ? accumulation / hoursElapsed : 0;
            const projectedFinal = currentRate * 24;
            
            // Calculate deficit based on current progress (not just projected value)
            // If current progress is low, we need to make up for the deficit
            const currentDeficit = Math.max(0, LIGHT_TARGET_DLI - accumulation);
            
            // Also consider projected deficit
            const projectedDeficit = Math.max(0, LIGHT_TARGET_DLI - projectedFinal);
            
            // Use the larger of current deficit or projected deficit to ensure we recommend enough light
            // But also consider remaining time: if we have little time left, focus on current deficit
            const deficit = remainingHours > 0 ? Math.max(currentDeficit, projectedDeficit * 0.8) : currentDeficit;
            
            // Estimate required supplemental light time (assuming 100% brightness from LED)
            // If we need X DLI-lite and LED provides 100 DLI-lite per hour, we need X/100 hours
            // Minimum 1 minute if there's any deficit
            const supplementalMinutes = deficit > 0 ? Math.max(1, Math.ceil((deficit / 100) * 60)) : 0;
            const needSupplementalLight = supplementalMinutes > 0 && targetProgress < 100;
            
            if (targetProgress >= 100) {
                return {
                    text: '‚úì Today\'s light is sufficient, no supplemental light needed.',
                    level: 'safe',
                    explanation: `Today's accumulated light has reached ${accumulation.toFixed(1)} DLI-lite, exceeding the target value of ${LIGHT_TARGET_DLI} DLI-lite (${targetProgress.toFixed(1)}% progress). Current light conditions are good, no supplemental light measures needed.`,
                    needSupplementalLight: false,
                    supplementalMinutes: 0
                };
            } else if (targetProgress >= 80) {
                // Even if progress is good, if there's a deficit, suggest minimal supplementation
                if (supplementalMinutes > 0) {
                    return {
                        text: `Recommend supplemental LED: +${supplementalMinutes} minutes`,
                        level: 'safe',
                        explanation: `Today's accumulated light ${accumulation.toFixed(1)} DLI-lite, progress ${targetProgress.toFixed(1)}%. Current light conditions are good, but recommend minimal supplemental light for ${supplementalMinutes} minutes to ensure target is reached.`,
                        needSupplementalLight: true,
                        supplementalMinutes: supplementalMinutes
                    };
                } else {
                    return {
                        text: 'Current light is good, continue monitoring.',
                        level: 'safe',
                        explanation: `Today's accumulated light ${accumulation.toFixed(1)} DLI-lite, progress ${targetProgress.toFixed(1)}%. Current light conditions are good, expected to reach target today. If shading or cloudy conditions occur later, system will recommend supplemental light.`,
                        needSupplementalLight: false,
                        supplementalMinutes: 0
                    };
                }
            } else if (targetProgress >= 50) {
                return {
                    text: `Recommend supplemental LED: +${supplementalMinutes} minutes`,
                    level: 'moderate',
                    explanation: `Today's accumulated light ${accumulation.toFixed(1)} DLI-lite, progress ${targetProgress.toFixed(1)}%. Based on current light rate, expected to fall short of target today. Recommend turning on supplemental light for ${supplementalMinutes} minutes to compensate for light deficiency.`,
                    needSupplementalLight: true,
                    supplementalMinutes: supplementalMinutes
                };
            } else {
                return {
                    text: `‚ö†Ô∏è Recommend immediately supplementing LED: +${supplementalMinutes} minutes`,
                    level: 'high',
                    explanation: `Today's accumulated light ${accumulation.toFixed(1)} DLI-lite, progress only ${targetProgress.toFixed(1)}%. Current light is severely insufficient, possibly due to cloudy conditions, shading, or equipment failure. Recommend immediately turning on supplemental light for ${supplementalMinutes} minutes to ensure crops receive sufficient light.`,
                    needSupplementalLight: true,
                    supplementalMinutes: supplementalMinutes
                };
            }
        }

        // Update light accumulation display
        function updateLightAccumulationDisplay(brightness, temperature = null, humidity = null) {
            const analysis = updateLightAccumulation(brightness);
            const recommendation = getLightAccumulationRecommendation(
                analysis.accumulation, 
                analysis.targetProgress, 
                analysis.brightness
            );
            
            // Âè™ÊúâÂú®Ëá™Âä®Ê®°Âºè‰∏ãÊâçÊâßË°åËá™Âä®Ë°•ÂÖâÈÄªËæë
            // Â¶ÇÊûúÂ§Ñ‰∫éÊâãÂä®Ê®°ÂºèÔºåË∑≥ËøáËá™Âä®Ë°•ÂÖâËß¶Âèë
            if (!isManualMode) {
                // Check if we need to trigger supplemental light action
                const currentLowLight = recommendation.needSupplementalLight && recommendation.supplementalMinutes > 0;
                
                // If low light condition detected and wasn't detected before, log event and trigger action
                if (currentLowLight && !lastEventState.lowLight) {
                    addEventLog('low_light_condition', {
                        message: `Low light condition detected, target DLI not met. Today's accumulated: ${analysis.accumulation.toFixed(1)} DLI-lite, progress: ${analysis.targetProgress.toFixed(1)}%, recommend supplemental light for ${recommendation.supplementalMinutes} minutes.`,
                        snapshot: {
                            light: brightness !== null ? brightness : 0,
                            temp: temperature !== null ? temperature : 0,
                            rh: humidity !== null ? humidity : 0
                        }
                    });
                    
                    // Trigger action to turn on grow light
                    triggerAction('grow_light_on', { minutes: recommendation.supplementalMinutes });
                    lastEventState.lowLight = true;
                } else if (!currentLowLight && lastEventState.lowLight) {
                    // Light condition improved, turn off grow light
                    triggerAction('grow_light_off');
                    lastEventState.lowLight = false;
                }
            }
            
            // Update real-time light intensity display
            const realTimeIntensityElement = document.getElementById('lightRealTimeIntensity');
            if (realTimeIntensityElement) {
                if (brightness !== null && brightness !== undefined && !isNaN(brightness)) {
                    realTimeIntensityElement.textContent = brightness.toFixed(1) + '%';
                } else {
                    realTimeIntensityElement.textContent = '--';
                }
            }
            
            // Update accumulation display
            const accumulationElement = document.getElementById('lightAccumulationValue');
            if (accumulationElement) {
                accumulationElement.textContent = analysis.accumulation.toFixed(1);
            }
            
            // Update target progress
            const progressElement = document.getElementById('lightTargetProgress');
            if (progressElement) {
                progressElement.textContent = analysis.targetProgress.toFixed(1) + '%';
            }
            
            // Update status
            const statusElement = document.getElementById('lightAccumulationStatus');
            const levelElement = document.getElementById('lightAccumulationLevel');
            if (statusElement && levelElement) {
                if (analysis.targetProgress >= 100) {
                    statusElement.textContent = '‚úì Sufficient';
                    levelElement.textContent = 'Sufficient';
                } else if (analysis.targetProgress >= 80) {
                    statusElement.textContent = '‚úì Good';
                    levelElement.textContent = 'Good';
                } else if (analysis.targetProgress >= 50) {
                    statusElement.textContent = '‚ö†Ô∏è Insufficient';
                    levelElement.textContent = 'Insufficient';
                } else {
                    statusElement.textContent = '‚ö†Ô∏è Severely Insufficient';
                    levelElement.textContent = 'Severely Insufficient';
                }
            }
            
            // Update recommendation
            const recommendationText = document.getElementById('lightAccumulationRecommendationText');
            const recommendationDiv = document.getElementById('lightAccumulationRecommendation');
            const whyExplanationText = document.getElementById('whyLightExplanationText');
            
            if (recommendationText) {
                recommendationText.textContent = recommendation.text;
            }
            if (whyExplanationText) {
                whyExplanationText.textContent = recommendation.explanation;
            }
            
            // Update card styling based on level
            const card = document.getElementById('lightAccumulationCard');
            const realTimeItem = document.getElementById('lightRealTimeItem');
            const accumulationItem = document.getElementById('lightAccumulationItem');
            const targetItem = document.getElementById('lightTargetItem');
            const statusItem = document.getElementById('lightStatusItem');
            
            if (card) {
                card.className = 'sensor-card light-accumulation-card ' + recommendation.level;
            }
            if (recommendationDiv) {
                recommendationDiv.className = 'heat-stress-recommendation ' + recommendation.level;
            }
            if (realTimeItem) {
                realTimeItem.className = 'heat-stress-item ' + recommendation.level;
            }
            if (accumulationItem) {
                accumulationItem.className = 'heat-stress-item ' + recommendation.level;
            }
            if (targetItem) {
                targetItem.className = 'heat-stress-item ' + recommendation.level;
            }
            if (statusItem) {
                statusItem.className = 'heat-stress-item ' + recommendation.level;
            }
        }

        // Initialize temperature chart
        function initTemperatureChart() {
            const ctx = document.getElementById('temperatureChart').getContext('2d');
            temperatureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Temperature (¬∞C)',
                        data: [],
                        borderColor: '#667eea',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }, {
                        label: 'Heat Stress Zone',
                        data: [],
                        borderColor: 'rgba(255, 107, 107, 0.3)',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        borderWidth: 0,
                        fill: true,
                        pointRadius: 0,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    spanGaps: false,  // Don't connect lines across null values
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Temperature (¬∞C)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'YYYY-MM-DD HH:mm'
                            },
                            title: {
                                display: true,
                                text: 'Time (24 hours)'
                            },
                            min: new Date(Date.now() - 24 * 60 * 60 * 1000),  // 24Â∞èÊó∂Ââç
                            max: new Date(),  // ÂΩìÂâçÊó∂Èó¥
                            ticks: {
                                maxTicksLimit: 12  // ÊØè2Â∞èÊó∂ÊòæÁ§∫‰∏Ä‰∏™Ê†áÁ≠æ
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Initialize real-time temperature chart
        function initRealtimeTemperatureChart() {
            const ctx = document.getElementById('realtimeTemperatureChart').getContext('2d');
            realtimeTemperatureChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Temperature (¬∞C)',
                        data: [],
                        borderColor: '#ff6b6b',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    spanGaps: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Temperature (¬∞C)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                maxTicksLimit: 20
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Initialize real-time humidity chart
        function initRealtimeHumidityChart() {
            const ctx = document.getElementById('realtimeHumidityChart').getContext('2d');
            realtimeHumidityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Humidity (%)',
                        data: [],
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    spanGaps: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Humidity (%)'
                            }
                        },
                        x: {
                            title: {
                                display: true,
                                text: 'Time'
                            },
                            ticks: {
                                maxTicksLimit: 20
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Initialize humidity chart
        function initHumidityChart() {
            const ctx = document.getElementById('humidityChart').getContext('2d');
            humidityChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Humidity (%)',
                        data: [],
                        borderColor: '#17a2b8',
                        backgroundColor: 'rgba(23, 162, 184, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    spanGaps: false,  // Don't connect lines across null values
                    scales: {
                        y: {
                            beginAtZero: false,
                            title: {
                                display: true,
                                text: 'Humidity (%)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'YYYY-MM-DD HH:mm'
                            },
                            title: {
                                display: true,
                                text: 'Time (24 hours)'
                            },
                            min: new Date(Date.now() - 24 * 60 * 60 * 1000),  // 24Â∞èÊó∂Ââç
                            max: new Date(),  // ÂΩìÂâçÊó∂Èó¥
                            ticks: {
                                maxTicksLimit: 12  // ÊØè2Â∞èÊó∂ÊòæÁ§∫‰∏Ä‰∏™Ê†áÁ≠æ
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Initialize light history chart
        function initLightChart() {
            const ctx = document.getElementById('lightChart');
            if (!ctx) return;
            
            lightChart = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: [],
                    datasets: [{
                        label: 'Light Brightness (%)',
                        data: [],
                        borderColor: '#ffc107',
                        backgroundColor: 'rgba(255, 193, 7, 0.1)',
                        borderWidth: 2,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    spanGaps: false,
                    scales: {
                        y: {
                            beginAtZero: false,
                            min: 0,
                            max: 100,
                            title: {
                                display: true,
                                text: 'Light Brightness (%)'
                            }
                        },
                        x: {
                            type: 'time',
                            time: {
                                unit: 'hour',
                                displayFormats: {
                                    hour: 'HH:mm'
                                },
                                tooltipFormat: 'YYYY-MM-DD HH:mm'
                            },
                            title: {
                                display: true,
                                text: 'Time (24 hours)'
                            },
                            min: () => {
                                // 24Â∞èÊó∂Ââç
                                return new Date(Date.now() - 24 * 60 * 60 * 1000);
                            },
                            max: () => {
                                // ÂΩìÂâçÊó∂Èó¥
                                return new Date();
                            },
                            ticks: {
                                maxTicksLimit: 12
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        }
                    }
                }
            });
        }

        // Initialize 24h chart switcher
        function init24hChartSwitcher(){
            const tabs = Array.from(document.querySelectorAll('.history-tab'));
            const panels = Array.from(document.querySelectorAll('.history-panel'));
            if (!tabs.length || !panels.length) return;

            // ‰Ω†ÁöÑ 24h ÂõæË°®ÂÆû‰æãÔºàChart.jsÔºâ‰∏ÄËà¨ÊòØËøô‰∫õÂÖ®Â±ÄÂèòÈáèÂêç
            const chartByPanelId = {
                chart24hTemp: (typeof temperatureChart !== 'undefined') ? temperatureChart : null,
                chart24hHum: (typeof humidityChart !== 'undefined') ? humidityChart : null,
                chart24hLight: (typeof lightChart !== 'undefined') ? lightChart : null,
            };

            const activate = (panelId) => {
                tabs.forEach(t => t.classList.toggle('active', t.dataset.panel === panelId));
                panels.forEach(p => p.classList.toggle('active', p.id === panelId));

                // ‰ªéÈöêËóèÂàáÂà∞ÊòæÁ§∫Êó∂ÔºåChart.js ÈúÄË¶Å resize ‰∏ÄÊ¨°Ôºå‰∏çÁÑ∂Â∞∫ÂØ∏ÂèØËÉΩ‰∏çÂØπ
                const c = chartByPanelId[panelId];
                if (c && typeof c.resize === 'function') setTimeout(() => c.resize(), 0);
            };

            tabs.forEach(t => t.addEventListener('click', () => activate(t.dataset.panel)));

            // ÂàùÂßãÂåñÊòæÁ§∫Á¨¨‰∏Ä‰∏™
            activate((tabs.find(t => t.classList.contains('active')) || tabs[0]).dataset.panel);
        }

        // Update status display
        function updateStatus(status, text) {
            const statusDot = document.getElementById('mqttStatus');
            const statusText = document.getElementById('mqttStatusText');
            
            statusDot.className = 'status-dot ' + status;
            statusText.textContent = text;
        }

        // Add log entry
        function addLog(message, type = 'info') {
            const logContainer = document.getElementById('logContainer');
            if (!logContainer) return; // Â¶ÇÊûúlogContainer‰∏çÂ≠òÂú®ÔºåÁõ¥Êé•ËøîÂõû
            
            const logEntry = document.createElement('div');
            logEntry.className = 'log-entry ' + type;
            const timestamp = new Date().toLocaleTimeString();
            logEntry.textContent = `[${timestamp}] ${message}`;
            logContainer.insertBefore(logEntry, logContainer.firstChild);
            
            while (logContainer.children.length > 50) {
                logContainer.removeChild(logContainer.lastChild);
            }
        }

        // Clear log entries
        function clearLog() {
            const logContainer = document.getElementById('logContainer');
            if (logContainer) {
                logContainer.innerHTML = '';
                addLog('Log cleared', 'info');
            }
        }

        // Translate Chinese alert messages to English
        function translateAlertMessage(message) {
            if (!message || typeof message !== 'string') {
                return message;
            }
            
            // Check if message contains Chinese characters
            const hasChinese = /[\u4e00-\u9fa5]/.test(message);
            if (!hasChinese) {
                return message; // Return as-is if no Chinese characters
            }
            
            // Translation mapping for common alert messages
            const translations = {
                // Air quality alerts
                'Á©∫Ê∞îË¥®Èáè': 'Air quality',
                'Á©∫Ê∞îË¥®ÈáèÂ∑Æ': 'Poor air quality',
                'Á©∫Ê∞îË¥®ÈáèÂèòÂ∑Æ': 'Air quality degraded',
                'Á©∫Ê∞îË¥®ÈáèÂ∑≤ÊÅ¢Â§ç': 'Air quality restored',
                'Á©∫Ê∞îË¥®ÈáèÊÅ¢Â§çÊ≠£Â∏∏': 'Air quality returned to normal',
                'Á©∫Ê∞îË¥®ÈáèÊåÅÁª≠Ë∂ÖËøá10Áßí': 'Poor air quality persisted for more than 10 seconds',
                'ÈÄöÈ£éÈ£éÊâáÂ∑≤ËøêË°å10Áßí‰ΩÜÁ©∫Ê∞îË¥®ÈáèÊú™ÊîπÂñÑ': 'Ventilation fan has been running for 10 seconds but air quality has not improved',
                
                // Temperature alerts
                'Ê∏©Â∫¶': 'Temperature',
                'Ê∏©Â∫¶Ë∂ÖËøá': 'Temperature exceeded',
                'Ê∏©Â∫¶Ë∂ÖËøáÈòàÂÄº': 'Temperature exceeded threshold',
                'Ê∏©Â∫¶ÊåÅÁª≠Ë∂ÖËøáÈòàÂÄº': 'Temperature exceeded threshold for more than 10 seconds',
                'Ê∏©Â∫¶Â∑≤ÊÅ¢Â§çÊ≠£Â∏∏': 'Temperature returned to normal',
                'Ê∏©Â∫¶Â∑≤ÈôçËá≥ÈòàÂÄº‰ª•‰∏ã': 'Temperature has dropped below threshold',
                'ÈÄöÈ£éÈ£éÊâáÂ∑≤ËøêË°å10Áßí‰ΩÜÊ∏©Â∫¶Êú™‰∏ãÈôç': 'Ventilation fan has been running for 10 seconds but temperature has not decreased',
                
                // General alerts
                'Êä•Ë≠¶': 'Alert',
                'Ë≠¶Êä•': 'Alert',
                'Ë≠¶Âëä': 'Warning',
                'ÈîôËØØ': 'Error',
                'ÂºÇÂ∏∏': 'Abnormal',
                'Ê£ÄÊµãÂà∞': 'Detected',
                'Â∑≤Ëß£ÂÜ≥': 'Resolved',
                'Â∑≤ÊÅ¢Â§ç': 'Restored',
                'ÊÅ¢Â§çÊ≠£Â∏∏': 'Returned to normal',
                'Ë∂ÖËøá': 'Exceeded',
                '‰Ωé‰∫é': 'Below',
                'ÈòàÂÄº': 'Threshold',
                'ÊåÅÁª≠': 'Persisted',
                'Áßí': 'seconds',
                'ÂàÜÈíü': 'minutes',
                'Â∞èÊó∂': 'hours',
            };
            
            // Try to translate common patterns
            let translatedMessage = message;
            
            // Translate common alert patterns (full sentences first for better accuracy)
            if (translatedMessage.includes('Á©∫Ê∞îË¥®ÈáèÊåÅÁª≠Ë∂ÖËøá10Áßí') || 
                translatedMessage.includes('Á©∫Ê∞îË¥®ÈáèÂ∑ÆÊåÅÁª≠Ë∂ÖËøá10Áßí') ||
                translatedMessage.includes('Á©∫Ê∞îË¥®ÈáèÂ∑Æ') && translatedMessage.includes('10Áßí')) {
                translatedMessage = 'Poor air quality persisted for more than 10 seconds, ventilation fan has been running for 10 seconds but air quality has not improved!';
            } else if (translatedMessage.includes('Ê∏©Â∫¶ÊåÅÁª≠Ë∂ÖËøáÈòàÂÄº') || 
                       translatedMessage.includes('Ê∏©Â∫¶Ë∂ÖËøáÈòàÂÄºË∂ÖËøá10Áßí') ||
                       translatedMessage.includes('Ê∏©Â∫¶Ë∂ÖËøáÈòàÂÄº') && translatedMessage.includes('10Áßí')) {
                translatedMessage = 'Temperature exceeded threshold for more than 10 seconds, ventilation fan has been running for 10 seconds but temperature has not decreased!';
            } else if (translatedMessage.includes('Á©∫Ê∞îË¥®Èáè') && (translatedMessage.includes('ÊÅ¢Â§ç') || translatedMessage.includes('Ê≠£Â∏∏'))) {
                translatedMessage = 'Air quality has returned to good';
            } else if (translatedMessage.includes('Ê∏©Â∫¶') && (translatedMessage.includes('ÊÅ¢Â§ç') || translatedMessage.includes('Ê≠£Â∏∏'))) {
                translatedMessage = 'Temperature has returned to normal';
            } else if (translatedMessage.includes('Ê∏©Â∫¶') && translatedMessage.includes('Ë∂ÖËøáÈòàÂÄº')) {
                translatedMessage = 'Temperature exceeded threshold';
            } else if (translatedMessage.includes('Ê∏©Â∫¶') && translatedMessage.includes('‰Ωé‰∫éÈòàÂÄº')) {
                translatedMessage = 'Temperature dropped below threshold';
            } else if (translatedMessage.includes('Á©∫Ê∞îË¥®Èáè') && translatedMessage.includes('Â∑Æ')) {
                translatedMessage = 'Poor air quality detected';
            } else {
                // Fallback: try to translate word by word (longer phrases first)
                const sortedTranslations = Object.entries(translations).sort((a, b) => b[0].length - a[0].length);
                for (const [chinese, english] of sortedTranslations) {
                    translatedMessage = translatedMessage.replace(new RegExp(chinese, 'g'), english);
                }
            }
            
            return translatedMessage;
        }

        // Add alert information
        function addAlert(alertType, message) {
            const alertList = document.getElementById('alertList');
            
            // If list is empty (only "No alerts" message), clear it
            if (alertList.children.length === 1 && alertList.children[0].textContent.includes('No alerts')) {
                alertList.innerHTML = '';
            }
            
            // Translate message if it contains Chinese
            const translatedMessage = translateAlertMessage(message);
            const translatedAlertType = translateAlertMessage(alertType);
            
            alertCount++;
            
            const alertItem = document.createElement('div');
            alertItem.className = 'alert-item';
            const timestamp = new Date().toLocaleString();
            alertItem.innerHTML = `
                <div class="alert-time">[${timestamp}] ${translatedAlertType}</div>
                <div class="alert-message">${translatedMessage}</div>
            `;
            alertList.insertBefore(alertItem, alertList.firstChild);
            
            // If it's an air quality alert, record alertItem and timestamp for later marking as resolved
            // Check both original and translated message for compatibility
            if (alertType === 'air_quality' || 
                translatedAlertType.toLowerCase().includes('air quality') ||
                translatedMessage.toLowerCase().includes('air quality') ||
                message.includes('air quality') || 
                message.includes('Á©∫Ê∞îË¥®Èáè')) {
                airQualityAlertInfo.alertItem = alertItem;
                airQualityAlertInfo.timestamp = Date.now();
            }
            
            // If it's a temperature alert, record alertItem and timestamp for later marking as resolved
            // Check both original and translated message for compatibility
            if (alertType === 'temperature' || 
                (translatedMessage.toLowerCase().includes('temperature') && translatedMessage.toLowerCase().includes('threshold')) ||
                (message.includes('temperature') && message.includes('threshold')) ||
                (message.includes('Ê∏©Â∫¶') && message.includes('ÈòàÂÄº'))) {
                temperatureAlertInfo.alertItem = alertItem;
                temperatureAlertInfo.timestamp = Date.now();
            }
            
            // Limit alert count
            while (alertList.children.length > 20) {
                alertList.removeChild(alertList.lastChild);
            }
            
            // Browser notification
            if (Notification.permission === 'granted') {
                new Notification('Smart Greenhouse System Alert', {
                    body: translatedMessage,
                    icon: 'üîî'
                });
            }
        }

        // Mark air quality alert as resolved if conditions are met
        function markAirQualityAlertAsResolvedIfNeeded() {
            // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊó∂Âô®ÔºàÂ¶ÇÊûúÊúâÔºâ
            if (airQualityAlertInfo.removalTimer) {
                clearTimeout(airQualityAlertInfo.removalTimer);
                airQualityAlertInfo.removalTimer = null;
            }
            
            if (airQualityAlertInfo.alertItem && airQualityAlertInfo.timestamp) {
                const elapsed = Date.now() - airQualityAlertInfo.timestamp;
                const TEN_SECONDS = 10 * 1000;  // 10Áßí
                
                // Â¶ÇÊûúÂ∑≤ÁªèËøá‰∫Ü10ÁßíÔºåÁ´ãÂç≥Ê†áËÆ∞‰∏∫Â∑≤Ëß£ÂÜ≥
                if (elapsed >= TEN_SECONDS) {
                    markAirQualityAlertAsResolved();
                    } else {
                    // Â¶ÇÊûúËøòÊ≤°Ëøá10ÁßíÔºåËÆæÁΩÆÂÆöÊó∂Âô®ÔºåÁ≠âÂæÖÂà∞10ÁßíÂêéÊ†áËÆ∞‰∏∫Â∑≤Ëß£ÂÜ≥
                    const remainingTime = TEN_SECONDS - elapsed;
                    airQualityAlertInfo.removalTimer = setTimeout(() => {
                        markAirQualityAlertAsResolved();
                    }, remainingTime);
                    console.log(`‚è≥ Air quality alert will be marked as resolved in ${(remainingTime / 1000).toFixed(1)} seconds`);
                }
            }
        }
        
        // Mark the air quality alert as resolved (but keep it in history)
        function markAirQualityAlertAsResolved() {
            if (airQualityAlertInfo.alertItem) {
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊ†áËÆ∞‰∏∫Â∑≤Ëß£ÂÜ≥ÔºàÈÅøÂÖçÈáçÂ§çÊ†áËÆ∞Ôºâ
                if (airQualityAlertInfo.alertItem.classList.contains('resolved')) {
                    return;
                }
                
                // Ê∑ªÂä†"Â∑≤Ëß£ÂÜ≥"Áä∂ÊÄÅÊ†áËÆ∞
                const statusDiv = document.createElement('div');
                statusDiv.className = 'alert-status';
                statusDiv.textContent = '‚úì Resolved (Air quality has returned to good)';
                
                // Ê∑ªÂä†Âà∞alertItem‰∏≠
                airQualityAlertInfo.alertItem.appendChild(statusDiv);
                
                // Ê∑ªÂä†resolvedÁ±ªÔºåÊîπÂèòÊ†∑Âºè
                airQualityAlertInfo.alertItem.classList.add('resolved');
                
                console.log('‚úÖ Air quality alert marked as resolved (air quality returned to good after 10 seconds)');
            }
            
            // Ê∏ÖÈô§Ë∑üË∏™‰ø°ÊÅØÔºà‰ΩÜ‰øùÁïôalertItemÂú®DOM‰∏≠Ôºâ
            airQualityAlertInfo.alertItem = null;
            airQualityAlertInfo.timestamp = null;
            if (airQualityAlertInfo.removalTimer) {
                clearTimeout(airQualityAlertInfo.removalTimer);
                airQualityAlertInfo.removalTimer = null;
            }
        }
        
        // Mark temperature alert as resolved if conditions are met
        function markTemperatureAlertAsResolvedIfNeeded() {
            // Ê∏ÖÈô§‰πãÂâçÁöÑÂÆöÊó∂Âô®ÔºàÂ¶ÇÊûúÊúâÔºâ
            if (temperatureAlertInfo.removalTimer) {
                clearTimeout(temperatureAlertInfo.removalTimer);
                temperatureAlertInfo.removalTimer = null;
            }
            
            if (temperatureAlertInfo.alertItem && temperatureAlertInfo.timestamp) {
                const elapsed = Date.now() - temperatureAlertInfo.timestamp;
                const TEN_SECONDS = 10 * 1000;  // 10Áßí
                
                // Â¶ÇÊûúÂ∑≤ÁªèËøá‰∫Ü10ÁßíÔºåÁ´ãÂç≥Ê†áËÆ∞‰∏∫Â∑≤Ëß£ÂÜ≥
                if (elapsed >= TEN_SECONDS) {
                    markTemperatureAlertAsResolved();
            } else {
                    // Â¶ÇÊûúËøòÊ≤°Ëøá10ÁßíÔºåËÆæÁΩÆÂÆöÊó∂Âô®ÔºåÁ≠âÂæÖÂà∞10ÁßíÂêéÊ†áËÆ∞‰∏∫Â∑≤Ëß£ÂÜ≥
                    const remainingTime = TEN_SECONDS - elapsed;
                    temperatureAlertInfo.removalTimer = setTimeout(() => {
                        markTemperatureAlertAsResolved();
                    }, remainingTime);
                    console.log(`‚è≥ Temperature alert will be marked as resolved in ${(remainingTime / 1000).toFixed(1)} seconds`);
                }
            }
        }
        
        // Mark the temperature alert as resolved (but keep it in history)
        function markTemperatureAlertAsResolved() {
            if (temperatureAlertInfo.alertItem) {
                // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊ†áËÆ∞‰∏∫Â∑≤Ëß£ÂÜ≥ÔºàÈÅøÂÖçÈáçÂ§çÊ†áËÆ∞Ôºâ
                if (temperatureAlertInfo.alertItem.classList.contains('resolved')) {
                    return;
                }
                
                // Ê∑ªÂä†"Â∑≤Ëß£ÂÜ≥"Áä∂ÊÄÅÊ†áËÆ∞
                const statusDiv = document.createElement('div');
                statusDiv.className = 'alert-status';
                statusDiv.textContent = '‚úì Resolved (Temperature has dropped below threshold)';
                
                // Ê∑ªÂä†Âà∞alertItem‰∏≠
                temperatureAlertInfo.alertItem.appendChild(statusDiv);
                
                // Ê∑ªÂä†resolvedÁ±ªÔºåÊîπÂèòÊ†∑Âºè
                temperatureAlertInfo.alertItem.classList.add('resolved');
                
                console.log('‚úÖ Temperature alert marked as resolved (temperature dropped below threshold after 10 seconds)');
            }
            
            // Ê∏ÖÈô§Ë∑üË∏™‰ø°ÊÅØÔºà‰ΩÜ‰øùÁïôalertItemÂú®DOM‰∏≠Ôºâ
            temperatureAlertInfo.alertItem = null;
            temperatureAlertInfo.timestamp = null;
            if (temperatureAlertInfo.removalTimer) {
                clearTimeout(temperatureAlertInfo.removalTimer);
                temperatureAlertInfo.removalTimer = null;
            }
        }

        // Update sensor data display
        function updateSensorData(data) {
            // Update RGB LED status - ÊòæÁ§∫ÂÆûÈôÖÂÄºÔºàËÆæÂ§á‰∏äÊä•ÁöÑÂÄºÔºâ
            const rgbLedCount = data.rgb_led_count !== undefined ? data.rgb_led_count : 0;
            document.getElementById('rgbLedCount').textContent = rgbLedCount + '/5';
            let rgbLedStatusText = '';
            if (rgbLedCount === 0) {
                rgbLedStatusText = '0/5 (All Off)';
            } else if (rgbLedCount === 5) {
                rgbLedStatusText = '5/5 (All On)';
            } else {
                rgbLedStatusText = `${rgbLedCount}/5`;
            }
            document.getElementById('rgbLedStatus').textContent = rgbLedStatusText;
            document.getElementById('rgbLedCard').className = 'sensor-card' + (rgbLedCount > 0 ? ' active' : '');
            
            // Ê£ÄÊü•ÁõÆÊ†áÂÄºÂíåÂÆûÈôÖÂÄºÊòØÂê¶ÂåπÈÖç
            const pendingElement = document.getElementById('rgbLedPending');
            if (targetLedCount !== null && isManualMode) {
                // Âú®ÊâãÂä®Ê®°Âºè‰∏ãÔºåÊØîËæÉÁõÆÊ†áÂÄºÂíåÂÆûÈôÖÂÄº
                if (rgbLedCount === targetLedCount) {
                    // ÂåπÈÖçÊàêÂäüÔºåÈöêËóèPendingÁä∂ÊÄÅ
                    if (pendingElement) {
                        pendingElement.style.display = 'none';
                    }
                    targetLedSetTime = null;  // Ê∏ÖÈô§Ë∂ÖÊó∂ËÆ°Êó∂
            } else {
                    // ‰∏çÂåπÈÖçÔºåÊòæÁ§∫PendingÁä∂ÊÄÅ
                    if (pendingElement) {
                        pendingElement.style.display = 'inline';
                    }
                    
                    // Ê£ÄÊü•Ë∂ÖÊó∂Ôºà3ÁßíÔºâ
                    if (targetLedSetTime !== null) {
                        const elapsed = Date.now() - targetLedSetTime;
                        if (elapsed > 3000) {
                            // Ë∂ÖÊó∂ÊèêÁ§∫ÔºàÂèØÈÄâÔºåËøôÈáåÂè™ËÆ∞ÂΩïÂà∞consoleÔºâ
                            console.warn(`‚ö†Ô∏è Device did not report new status within 3 seconds. Target: ${targetLedCount}, Actual: ${rgbLedCount}`);
                            // ÂèØ‰ª•Âú®ËøôÈáåÊ∑ªÂä†Áî®Êà∑ÂèØËßÅÁöÑÊèêÁ§∫
                        }
                    }
                }
            } else {
                // Ëá™Âä®Ê®°Âºè‰∏ãÔºåÈöêËóèPendingÁä∂ÊÄÅ
                if (pendingElement) {
                    pendingElement.style.display = 'none';
                }
            }
            
            // Debug log for MQTT payload
            if (data.rgb_led_count !== undefined) {
                console.log('üì• RGB LED MQTT payload:', { 
                    rgb_led_count: data.rgb_led_count, 
                    target: targetLedCount, 
                    isManualMode: isManualMode,
                    match: rgbLedCount === targetLedCount
                });
            }
            
            // Update air quality detection (‰∫∫Èù†ËøëÊó∂Á©∫Ê∞îË¥®ÈáèÂèòÂ∑Æ)
            const hasPerson = data.person_detected === true;  // person_detected === true Ë°®Á§∫‰∫∫Èù†ËøëÔºåÁ©∫Ê∞îË¥®ÈáèÂèòÂ∑Æ
            const airQualityGood = !hasPerson;  // Ê≤°Êúâ‰∫∫Èù†ËøëÊó∂ÔºåÁ©∫Ê∞îË¥®ÈáèËâØÂ•Ω
            
            // ÂΩìÊ£ÄÊµãÂà∞Á©∫Ê∞îË¥®ÈáèÂ∑ÆÊó∂ÔºåËá™Âä®Ëß¶ÂèëÈ£éÊâáÈÄöÈ£é
            if (!airQualityGood && !lastEventState.airQualityPoor) {
                // Á©∫Ê∞îË¥®ÈáèÂèòÂ∑ÆÔºåËß¶ÂèëÈ£éÊâáÂºÄÂêØ
                addEventLog('poor_air_quality', {
                    message: `Poor air quality detected (person nearby), recommend turning on ventilation.`,
                    snapshot: {
                        temp: data.temperature !== undefined ? data.temperature : 0,
                        rh: data.humidity !== undefined ? data.humidity : 0
                    }
                });
                triggerAction('fan_on_air_quality');  // ÂèëÈÄÅÈ£éÊâáÂºÄÂêØÂëΩ‰ª§
                lastEventState.airQualityPoor = true;
            } else if (airQualityGood && lastEventState.airQualityPoor) {
                // Á©∫Ê∞îË¥®ÈáèÊÅ¢Â§çËâØÂ•ΩÔºåÂÖ≥Èó≠È£éÊâá
                triggerAction('fan_off_air_quality');
                lastEventState.airQualityPoor = false;
                
                // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÊ†áËÆ∞Á©∫Ê∞îË¥®ÈáèÊä•Ë≠¶‰∏∫Â∑≤Ëß£ÂÜ≥Ôºà10ÁßíÂêéËá™Âä®Ê†áËÆ∞Ôºâ
                markAirQualityAlertAsResolvedIfNeeded();
            }
            
            // Update fan status
            const fanStatus = data.fan_status === 'ON';
            const fanMode = data.fan_mode || 'auto';
            document.getElementById('fanStatus').textContent = fanStatus ? 'ON' : 'OFF';
            document.getElementById('fanStatusBadge').textContent = fanStatus ? 'ON' : 'OFF';
            document.getElementById('fanStatusBadge').className = 'sensor-status ' + (fanStatus ? 'on' : 'off');
            document.getElementById('fanCard').className = 'sensor-card' + (fanStatus ? ' active' : '');
            document.getElementById('fanMode').textContent = 'Mode: Auto';  // Fan only supports auto mode now
            
            // Update temperature threshold
            if (data.temp_threshold !== undefined) {
                const threshold = parseFloat(data.temp_threshold);
                const tempThresholdSlider = document.getElementById('tempThresholdSlider');
                const tempThresholdDisplay = document.getElementById('tempThresholdDisplay');
                const currentTempThreshold = document.getElementById('currentTempThreshold');
                
                // Always update the display of current threshold
                if (currentTempThreshold) {
                    currentTempThreshold.textContent = threshold.toFixed(1) + '¬∞C';
                }
                
                // Update slider if user is not currently dragging it
                if (tempThresholdSlider) {
                    if (document.activeElement !== tempThresholdSlider || tempThresholdJustUpdated) {
                        tempThresholdSlider.value = threshold.toFixed(1);
                        if (tempThresholdDisplay) {
                            tempThresholdDisplay.textContent = threshold.toFixed(1);
                        }
                        tempThresholdJustUpdated = false;  // Reset flag after update
                    }
                }
                
                // Update temperature comparison display
                updateTemperatureComparison(data.temperature, threshold);
            }
            
            // Update Dashboard values
            if (data.temperature !== undefined && data.temperature !== null) {
                const tempElement = document.getElementById('dashboardTemperature');
                if (tempElement) {
                    tempElement.textContent = data.temperature.toFixed(1);
                }
            }
            
            if (data.humidity !== undefined && data.humidity !== null) {
                const humidityElement = document.getElementById('dashboardHumidity');
                if (humidityElement) {
                    humidityElement.textContent = data.humidity.toFixed(1);
                }
            }
            
            if (data.light !== undefined) {
                const lightADC = data.light || 0;
                const lightBrightness = 100.0 - (lightADC * 100.0 / 4095.0);
                const lightElement = document.getElementById('dashboardLight');
                if (lightElement) {
                    lightElement.textContent = lightBrightness.toFixed(1);
                }
            }
            
            // Update Dashboard air quality
            const dashboardAirQualityElement = document.getElementById('dashboardAirQuality');
            const dashboardAirQualityBadge = document.getElementById('dashboardAirQualityBadge');
            if (dashboardAirQualityElement && dashboardAirQualityBadge) {
                const hasPerson = data.person_detected === true;
                const airQualityGood = !hasPerson;
                dashboardAirQualityElement.textContent = airQualityGood ? 'Good' : 'Poor';
                dashboardAirQualityBadge.textContent = airQualityGood ? 'Good' : 'Poor';
                dashboardAirQualityBadge.className = 'status-indicator ' + (airQualityGood ? 'offline' : 'online');
            }
            
            // Update temperature comparison (even if threshold not updated)
            if (data.temperature !== undefined && data.temperature !== null) {
                const currentThreshold = parseFloat(document.getElementById('currentTempThreshold')?.textContent) || 25.0;
                updateTemperatureComparison(data.temperature, currentThreshold);
                
                // Ê£ÄÊü•Ê∏©Â∫¶ÊòØÂê¶ÊÅ¢Â§çÊ≠£Â∏∏Ôºà‰Ωé‰∫éÈòàÂÄºÔºâÔºåÂ¶ÇÊûúÊòØÔºåÊ†áËÆ∞Ê∏©Â∫¶Êä•Ë≠¶‰∏∫Â∑≤Ëß£ÂÜ≥
                if (data.temperature <= currentThreshold && temperatureAlertInfo.alertItem) {
                    markTemperatureAlertAsResolvedIfNeeded();
                }
            }
            
            // Update heat stress analysis
            if (data.temperature !== undefined && data.temperature !== null && 
                data.humidity !== undefined && data.humidity !== null) {
                updateHeatStressDisplay(data.temperature, data.humidity);
            }
            
            // Update light accumulation analysis
            if (data.light !== undefined) {
                const lightADC = data.light || 0;
                const lightBrightness = 100.0 - (lightADC * 100.0 / 4095.0);
                const temperature = data.temperature !== undefined ? data.temperature : null;
                const humidity = data.humidity !== undefined ? data.humidity : null;
                updateLightAccumulationDisplay(lightBrightness, temperature, humidity);
            }
            
            // Update charts (temperature and humidity use the same time labels)
            const now = new Date();
            const nowTime = now.getTime();
            const twentyFourHoursAgo = nowTime - 24 * 60 * 60 * 1000; // 24Â∞èÊó∂ÂâçÁöÑÊó∂Èó¥Êà≥
            // ÂßãÁªà‰ΩøÁî®DateÂØπË±°‰Ωú‰∏∫Ê†áÁ≠æÔºàChart.js time scaleÈúÄË¶ÅDateÂØπË±°Ôºâ
            const timeLabel = now;
            let chartUpdated = false;
            
            // Helper function to remove data points older than 24 hours
            function removeOldDataPoints(chart, datasetIndex = 0) {
                if (!chart || !chart.data || !chart.data.labels) return;
                
                const labels = chart.data.labels;
                const dataset = chart.data.datasets[datasetIndex];
                
                if (!labels || labels.length === 0) return;
                
                const originalLength = labels.length;
                
                // ‰ªéÂâçÂæÄÂêéÊü•ÊâæÔºåÊâæÂà∞Á¨¨‰∏Ä‰∏™Âú®24Â∞èÊó∂ÂÜÖÁöÑÊï∞ÊçÆÁÇπ
                // Ëøô‰∏™ÁÇπ‰πãÂâçÁöÑÊâÄÊúâÁÇπÈÉΩÂ∫îËØ•Ë¢´Âà†Èô§ÔºàÂõ†‰∏∫ÂÆÉ‰ª¨ÈÉΩË∂ÖËøá24Â∞èÊó∂‰∫ÜÔºâ
                let firstValidIndex = -1;
                for (let i = 0; i < labels.length; i++) {
                    const labelTime = labels[i] instanceof Date ? labels[i].getTime() : new Date(labels[i]).getTime();
                    if (labelTime >= twentyFourHoursAgo) {
                        firstValidIndex = i;
                        break; // ÊâæÂà∞Á¨¨‰∏Ä‰∏™Âú®24Â∞èÊó∂ÂÜÖÁöÑÁÇπÔºåÂÅúÊ≠¢Êü•Êâæ
                    }
                }
                
                // Â¶ÇÊûúÊâæÂà∞‰∫ÜÊúâÊïàÁ¥¢ÂºïÔºåÂà†Èô§Ëøô‰∏™Á¥¢Âºï‰πãÂâçÁöÑÊâÄÊúâÊóßÊï∞ÊçÆ
                if (firstValidIndex > 0) {
                    const removeCount = firstValidIndex;
                    labels.splice(0, removeCount);
                    if (dataset && dataset.data) {
                        // Á°Æ‰øùÊï∞ÊçÆÈõÜÈïøÂ∫¶ÂíålabelsÈïøÂ∫¶‰∏ÄËá¥
                        if (dataset.data.length >= removeCount) {
                            dataset.data.splice(0, removeCount);
                        } else {
                            // Â¶ÇÊûúÊï∞ÊçÆÈõÜÈïøÂ∫¶Â∞è‰∫élabelsÈïøÂ∫¶ÔºåË∞ÉÊï¥Êï∞ÊçÆÈõÜÈïøÂ∫¶
                            dataset.data.splice(0, dataset.data.length);
                            // Áî®nullÂ°´ÂÖÖÂà∞‰∏élabelsÁõ∏ÂêåÁöÑÈïøÂ∫¶
                            while (dataset.data.length < labels.length) {
                                dataset.data.unshift(null);
                            }
                        }
                    }
                } else if (firstValidIndex === -1) {
                    // Â¶ÇÊûúÊâÄÊúâÊï∞ÊçÆÈÉΩË∂ÖËøá24Â∞èÊó∂ÔºåÂè™‰øùÁïôÊúÄÂêé‰∏Ä‰∏™ÁÇπÔºàÂΩìÂâçÁÇπÔºâ
                    if (labels.length > 1) {
                        const keepCount = 1;
                        labels.splice(0, labels.length - keepCount);
                        if (dataset && dataset.data) {
                            if (dataset.data.length > keepCount) {
                                dataset.data.splice(0, dataset.data.length - keepCount);
                            } else {
                                // Â¶ÇÊûúÊï∞ÊçÆÈõÜÈïøÂ∫¶‰∏çË∂≥ÔºåÁî®nullÂ°´ÂÖÖ
                                while (dataset.data.length < labels.length) {
                                    dataset.data.unshift(null);
                                }
                            }
                        }
                    }
                }
                // Â¶ÇÊûúfirstValidIndex === 0ÔºåËØ¥ÊòéÁ¨¨‰∏Ä‰∏™ÁÇπÂ∞±Âú®24Â∞èÊó∂ÂÜÖÔºå‰∏çÈúÄË¶ÅÂà†Èô§‰ªª‰ΩïÁÇπ
                
                // Ë∞ÉËØïÊó•ÂøóÔºà‰ªÖÂú®Êï∞ÊçÆÁÇπÊï∞ÈáèÂèòÂåñÊó∂ËæìÂá∫Ôºâ
                if (labels.length !== originalLength) {
                    console.log(`üìä Chart data cleanup: ${originalLength} -> ${labels.length} points (dataset ${datasetIndex})`);
                }
            }
            
            // Update temperature chart (24 hours history)
            if (data.temperature !== undefined && data.temperature !== null) {
                // Always append new data
                temperatureChart.data.labels.push(timeLabel);
                temperatureChart.data.datasets[0].data.push(data.temperature);
                
                // Update heat stress zone overlay
                if (data.humidity !== undefined && data.humidity !== null) {
                    const isStress = isHeatStressCondition(data.temperature, data.humidity);
                    // Add heat stress zone data (show as shaded area when stress occurs)
                    if (temperatureChart.data.datasets[1]) {
                        if (isStress) {
                            temperatureChart.data.datasets[1].data.push(data.temperature);
                        } else {
                            temperatureChart.data.datasets[1].data.push(null);
                        }
                    }
                }
                
                // Remove data points older than 24 hours (based on timestamp, not count)
                removeOldDataPoints(temperatureChart, 0);
                if (temperatureChart.data.datasets[1]) {
                    removeOldDataPoints(temperatureChart, 1);
                }
                
                // Update chart with animation disabled, but force time scale update
                // ‰ΩøÁî®Âõ∫ÂÆöÂÄºËÄå‰∏çÊòØÂáΩÊï∞ÔºåÁ°Æ‰øùÊó∂Èó¥ËΩ¥Ê≠£Á°ÆÊõ¥Êñ∞
                const chartMinTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
                const chartMaxTime = new Date();
                temperatureChart.options.scales.x.min = chartMinTime;
                temperatureChart.options.scales.x.max = chartMaxTime;
                temperatureChart.update('none');
                chartUpdated = true;
                
                // Update real-time temperature chart (Âè™ÊòæÁ§∫ÂÆûÊó∂Êï∞ÊçÆ)
                if (realtimeTemperatureChart) {
                    const realtimeTimeLabel = now.toLocaleTimeString();
                    realtimeTemperatureChart.data.labels.push(realtimeTimeLabel);
                    realtimeTemperatureChart.data.datasets[0].data.push(data.temperature);
                    
                    // ‰øùÊåÅÊúÄÂ§ö50‰∏™ÂÆûÊó∂Êï∞ÊçÆÁÇπÔºàÊªöÂä®Á™óÂè£Ôºâ
                    if (realtimeTemperatureChart.data.labels.length > 50) {
                        realtimeTemperatureChart.data.labels.shift();
                        realtimeTemperatureChart.data.datasets[0].data.shift();
                    }
                    
                    realtimeTemperatureChart.update('none');
                }
            }
            
            // Update humidity charts
            if (data.humidity !== undefined) {
                // Êõ¥Êñ∞24Â∞èÊó∂ÂéÜÂè≤ÊπøÂ∫¶ÂõæË°®
                // ÂßãÁªà‰ΩøÁî®DateÂØπË±°‰Ωú‰∏∫Ê†áÁ≠æÔºàChart.js time scaleÈúÄË¶ÅDateÂØπË±°Ôºâ
                const humidityTimeLabel = now;
                
                humidityChart.data.labels.push(humidityTimeLabel);
                humidityChart.data.datasets[0].data.push(data.humidity);
                
                // Remove data points older than 24 hours (based on timestamp, not count)
                removeOldDataPoints(humidityChart, 0);
                
                // Update chart with animation disabled, but force time scale update
                // ‰ΩøÁî®Âõ∫ÂÆöÂÄºËÄå‰∏çÊòØÂáΩÊï∞ÔºåÁ°Æ‰øùÊó∂Èó¥ËΩ¥Ê≠£Á°ÆÊõ¥Êñ∞
                const chartMinTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
                const chartMaxTime = new Date();
                humidityChart.options.scales.x.min = chartMinTime;
                humidityChart.options.scales.x.max = chartMaxTime;
                humidityChart.update('none');
                
                // Êõ¥Êñ∞ÂÆûÊó∂ÊπøÂ∫¶ÂõæË°®ÔºàÂè™ÊòæÁ§∫ÂÆûÊó∂Êï∞ÊçÆÔºâ
                if (realtimeHumidityChart) {
                    const realtimeHumidityTimeLabel = now.toLocaleTimeString();
                    realtimeHumidityChart.data.labels.push(realtimeHumidityTimeLabel);
                    realtimeHumidityChart.data.datasets[0].data.push(data.humidity);
                    
                    // ‰øùÊåÅÊúÄÂ§ö50‰∏™ÂÆûÊó∂Êï∞ÊçÆÁÇπÔºàÊªöÂä®Á™óÂè£Ôºâ
                    if (realtimeHumidityChart.data.labels.length > 50) {
                        realtimeHumidityChart.data.labels.shift();
                        realtimeHumidityChart.data.datasets[0].data.shift();
                    }
                    
                    realtimeHumidityChart.update('none');
                }
            }
            
            // Update light chart
            if (data.light !== undefined && lightChart) {
                const lightADC = data.light || 0;
                const lightBrightness = 100.0 - (lightADC * 100.0 / 4095.0);
                // ÂßãÁªà‰ΩøÁî®DateÂØπË±°‰Ωú‰∏∫Ê†áÁ≠æÔºàChart.js time scaleÈúÄË¶ÅDateÂØπË±°Ôºâ
                const lightTimeLabel = now;
                
                lightChart.data.labels.push(lightTimeLabel);
                lightChart.data.datasets[0].data.push(lightBrightness);
                
                // Remove data points older than 24 hours (based on timestamp, not count)
                removeOldDataPoints(lightChart, 0);
                
                // Update chart with animation disabled, but force time scale update
                // ‰ΩøÁî®Âõ∫ÂÆöÂÄºËÄå‰∏çÊòØÂáΩÊï∞ÔºåÁ°Æ‰øùÊó∂Èó¥ËΩ¥Ê≠£Á°ÆÊõ¥Êñ∞
                const chartMinTime = new Date(Date.now() - 24 * 60 * 60 * 1000);
                const chartMaxTime = new Date();
                lightChart.options.scales.x.min = chartMinTime;
                lightChart.options.scales.x.max = chartMaxTime;
                lightChart.update('none');
            }
            
            // Message count display removed
        }

        // Process history data and populate charts
        function processHistoryData(historyData) {
            try {
            // Â¶ÇÊûúÂ∑≤ÁªèÂä†ËΩΩËøáÂéÜÂè≤Êï∞ÊçÆÔºåË∑≥ËøáÂêéÁª≠Â§ÑÁêÜ
            if (historyLoaded) {
                console.log('‚è≠Ô∏è History data already loaded, skipping duplicate processing');
                return;
            }
                
                console.log('Processing history data:', historyData);
                
                if (!historyData.points || !Array.isArray(historyData.points)) {
                    addLog('Invalid history data format: points is not an array', 'error');
                    console.error('Invalid history data:', historyData);
                    return;
                }
                
                // Ëé∑ÂèñÊï∞ÊçÆÁÇπÊï∞ÁªÑ
                const points = historyData.points;
                
                // Ë∞ÉËØïÔºöÊâìÂç∞ÂâçÂá†‰∏™Êï∞ÊçÆÁÇπÁöÑËØ¶ÁªÜ‰ø°ÊÅØ
                console.log('üîç Data validation debug:');
                console.log('  - Total data points:', points.length);
                console.log('  - First 5 data points:', points.slice(0, 5));
                console.log('  - First 5 data point types:', points.slice(0, 5).map(p => typeof p));
                console.log('  - First 5 data point values:', points.slice(0, 5).map(p => {
                    if (p === null || p === undefined || p === '') return 'null/empty';
                    const num = typeof p === 'string' ? parseFloat(p) : Number(p);
                    return isNaN(num) ? 'NaN' : (isFinite(num) ? num : 'Infinity');
                }));
                
                // Ê£ÄÊü•Êï∞ÊçÆÊòØÂê¶ÊúâÊïàÔºàËá≥Â∞ëÊúâ‰∏Ä‰∫õÈùûnullÊï∞ÊçÆÁÇπÔºâ
                // Ê≥®ÊÑèÔºö0.0 ÊòØÊúâÊïàÂÄºÔºå‰∏çÂ∫îËØ•Ë¢´ËøáÊª§Êéâ
                const validPoints = points.filter(p => {
                    if (p === null || p === undefined || p === '') return false;
                    const num = typeof p === 'string' ? parseFloat(p) : Number(p);
                    // 0.0 ÊòØÊúâÊïàÂÄºÔºåÂ∫îËØ•Ë¢´ÂåÖÂê´
                    return !isNaN(num) && isFinite(num);
                });
                
                console.log('  - Valid data points:', validPoints.length);
                console.log('  - Valid data point examples:', validPoints.slice(0, 5));
                
                // Âç≥‰ΩøÊâÄÊúâÊï∞ÊçÆÁÇπÈÉΩÊòØ0.0ÔºàÂàùÂßãÂÄºÔºâÔºå‰πüÂ∫îËØ•ÁªßÁª≠Â§ÑÁêÜÔºåÂõ†‰∏∫ËøôÊ†∑ÂèØ‰ª•ÊòæÁ§∫Êó∂Èó¥ËΩ¥
                // Âè™ÊúâÂΩìÊï∞ÊçÆÁÇπÊï∞ÁªÑ‰∏∫Á©∫ÊàñÊ†ºÂºèÈîôËØØÊó∂ÊâçËøîÂõû
                if (!points || points.length === 0) {
                    console.warn('‚è≠Ô∏è History data points array is empty');
                    return;
                }
                
                // Â¶ÇÊûúÊâÄÊúâÊï∞ÊçÆÁÇπÈÉΩÊòØnull/undefined/Á©∫Â≠óÁ¨¶‰∏≤ÔºåËÆ∞ÂΩïË≠¶Âëä‰ΩÜÁªßÁª≠Â§ÑÁêÜ
                if (validPoints.length === 0) {
                    console.warn('‚ö†Ô∏è All data points are null/undefined/empty string or NaN');
                    console.warn('   This may be because the bridge has not collected real data yet, or there is a data format issue');
                    console.warn('   Will continue processing to at least display the time axis');
                }
                
                // ÈÅøÂÖçÈ¢ëÁπÅÊõ¥Êñ∞ÔºöÂ¶ÇÊûúÊó∂Èó¥Êà≥ÂèòÂåñÂæàÂ∞èÔºàÂ∞è‰∫é5ÁßíÔºâÔºåÂèØËÉΩÊòØÂêå‰∏ÄÊâπÊï∞ÊçÆ
                const currentT0 = historyData.t0;
                if (lastHistoryT0 !== null) {
                    const timeDiff = Math.abs(currentT0 - lastHistoryT0);
                    if (timeDiff < 5000 && timeDiff > 0) {
                        // Êó∂Èó¥Êà≥ÂèòÂåñÂæàÂ∞èÔºåÂèØËÉΩÊòØÊï∞ÊçÆÊªöÂä®ÂØºËá¥ÁöÑÔºå‰ªçÁÑ∂Êõ¥Êñ∞ÔºàÂõ†‰∏∫Êï∞ÊçÆÂèØËÉΩÂ∑≤ÁªèÂèòÂåñÔºâ
                        console.log(`üîÑ Timestamp fine-tuning: ${timeDiff}ms, continuing to update data`);
                    } else if (currentT0 === lastHistoryT0) {
                        console.log('‚è≠Ô∏è Skipping identical history data (same t0)');
                        return;
                    }
                }
                lastHistoryT0 = currentT0;
                // BridgeÂèëÈÄÅÁöÑeverySecÊòØ600Ôºà10ÂàÜÈíüÔºâÔºå‰∏çÊòØ60Áßí
                // BridgeÂèëÈÄÅ144‰∏™Êï∞ÊçÆÁÇπÔºà24Â∞èÊó∂ √ó 6‰∏™10ÂàÜÈíüÈó¥Èöî = 144‰∏™ÁÇπÔºâ
                const everySec = historyData.everySec || 600;  // ÈªòËÆ§600ÁßíÔºà10ÂàÜÈíüÈó¥ÈöîÔºâ
                let t0 = historyData.t0 || Date.now();
                
                // ÂÖàËé∑ÂèñÊπøÂ∫¶ÂíåÂÖâÁÖßÂéÜÂè≤Êï∞ÊçÆÔºàÂ¶ÇÊûúÂ≠òÂú®ÔºâÔºåÂøÖÈ°ªÂú®È™åËØÅ‰πãÂâçËé∑Âèñ
                let humidityPoints = historyData.humidity_points || [];
                let lightPoints = historyData.light_points || [];
                
                // Â¶ÇÊûúÊî∂Âà∞1440‰∏™ÁÇπ‰∏îeverySec=60ÔºåËØ¥ÊòébridgeÂèëÈÄÅÁöÑÊòØÊØè1ÂàÜÈíü‰∏Ä‰∏™ÁÇπ
                // ÈúÄË¶ÅËΩ¨Êç¢‰∏∫144‰∏™ÁÇπÔºàÊØè10ÂàÜÈíü‰∏Ä‰∏™ÁÇπÔºâ
                if (points.length === 1440 && everySec === 60) {
                    console.warn(`‚ö†Ô∏è Detected data format: received 1440 points (every 1 minute), need to convert to 144 points (every 10 minutes)`);
                    const convertedPoints = [];
                    const convertedHumidityPoints = [];
                    const convertedLightPoints = [];
                    
                    // ÊØè10‰∏™ÁÇπÂèñ1‰∏™Ôºà‰ªéÁ¨¨0‰∏™ÂºÄÂßãÔºåÊØè10‰∏™Âèñ‰∏Ä‰∏™Ôºâ
                    for (let j = 0; j < 144; j++) {
                        const sourceIndex = j * 10;
                        if (sourceIndex < points.length) {
                            convertedPoints.push(points[sourceIndex]);
                            if (sourceIndex < humidityPoints.length) {
                                convertedHumidityPoints.push(humidityPoints[sourceIndex]);
                            }
                            if (sourceIndex < lightPoints.length) {
                                convertedLightPoints.push(lightPoints[sourceIndex]);
                            }
                        }
                    }
                    
                    // ÊõøÊç¢ÂéüÂßãÊï∞ÊçÆ
                    points.length = 0;
                    points.push(...convertedPoints);
                    humidityPoints.length = 0;
                    humidityPoints.push(...convertedHumidityPoints);
                    lightPoints.length = 0;
                    lightPoints.push(...convertedLightPoints);
                    
                    console.log(`‚úÖ Data converted: 1440 points ‚Üí 144 points (every 10 minutes)`);
                }
                
                // È™åËØÅÊï∞ÊçÆÁÇπÊï∞ÈáèÔºàÂ∫îËØ•ÊòØ144‰∏™Ôºâ
                if (points.length !== 144) {
                    console.warn(`‚ö†Ô∏è Abnormal data point count: received ${points.length} points, expected 144 points (24 hours √ó 6 ten-minute intervals)`);
                    if (points.length > 144) {
                        console.warn(`   Will only process the first 144 data points`);
                        points.length = 144;
                        if (humidityPoints.length > 144) {
                            humidityPoints.length = 144;
                        }
                        if (lightPoints.length > 144) {
                            lightPoints.length = 144;
                        }
                    } else if (points.length < 144) {
                        console.warn(`   Insufficient data points, bridge may not have collected enough data yet`);
                    }
                } else {
                    console.log(`‚úÖ Data point count correct: 144 points (24 hours √ó 6 ten-minute intervals)`);
                }
                
                // È™åËØÅeverySecÔºàÂ∫îËØ•ÊòØ600ÁßíÔºåÂç≥10ÂàÜÈíüÔºâ
                // Â¶ÇÊûú‰πãÂâçÊòØ60ÁßíÔºåÁé∞Âú®Â∑≤ÁªèËΩ¨Êç¢‰∏∫144‰∏™ÁÇπÔºåÂ∫îËØ•‰ΩøÁî®600Áßí‰Ωú‰∏∫Èó¥Èöî
                let actualEverySec = everySec;
                if (everySec === 60 && points.length === 144) {
                    actualEverySec = 600;
                    console.log(`‚úÖ Time interval corrected: 60 seconds ‚Üí 600 seconds (10 minutes)`);
                } else if (everySec !== 600) {
                    console.warn(`‚ö†Ô∏è Abnormal time interval: everySec=${everySec} seconds, expected 600 seconds (10 minutes)`);
                    console.warn(`   Will use 600 seconds as the time interval for calculation`);
                    actualEverySec = 600;
                } else {
                    console.log(`‚úÖ Time interval correct: 600 seconds (10 minutes)`);
                }
                
                // ‰ΩøÁî®‰øÆÊ≠£ÂêéÁöÑÊó∂Èó¥Èó¥Èöî
                const finalEverySec = actualEverySec || 600;
                
                // Ë∞ÉËØï‰ø°ÊÅØÔºöÊâìÂç∞Êó∂Èó¥Êà≥ÂíåÈó¥Èöî
                console.log(`üîç Timestamp debug: t0=${t0} (${new Date(t0).toLocaleString()}), everySec=${everySec} seconds ‚Üí finalEverySec=${finalEverySec} seconds, points.length=${points.length}`);
                
                // È™åËØÅÊó∂Èó¥Êà≥ÊòØÂê¶ÂêàÁêÜ
                const now = Date.now();
                const oneDayAgo = now - 24 * 60 * 60 * 1000;
                const maxFutureTime = now + 60 * 60 * 1000; // ÊúÄÂ§öÂÖÅËÆ∏1Â∞èÊó∂ÂêéÁöÑÊó∂Èó¥
                
                // ËÆ°ÁÆóÂéÜÂè≤Êï∞ÊçÆÁöÑÁªìÊùüÊó∂Èó¥Ôºà‰ΩøÁî®‰øÆÊ≠£ÂêéÁöÑÊó∂Èó¥Èó¥ÈöîÔºâ
                const historyEndTime = t0 + (points.length * finalEverySec * 1000);
                
                // Ê£ÄÊü•Êó∂Èó¥Êà≥ÊòØÂê¶ÂêàÁêÜ
                const timeDiff = t0 - now;
                const hoursDiff = timeDiff / (1000 * 60 * 60);
                
                // Â¶ÇÊûút0ÊòØÊú™Êù•Êó∂Èó¥ÔºàË∂ÖËøá1Â∞èÊó∂ÔºâÔºå‰øÆÊ≠£‰∏∫ÂΩìÂâçÊó∂Èó¥ÂæÄÂâçÊé®24Â∞èÊó∂
                // ‰ΩÜÂ¶ÇÊûút0Âè™ÊòØÁ®çÂæÆÊóß‰∏ÄÁÇπÔºàÊØîÂ¶Ç25Â∞èÊó∂ÂâçÔºâÔºå‰∏çÂ∫îËØ•‰øÆÊ≠£ÔºåÂõ†‰∏∫ÂéÜÂè≤Êï∞ÊçÆÂèØËÉΩÁ°ÆÂÆûÊòØ‰ªéÊò®Â§©ÂºÄÂßãÁöÑ
                // Âè™ÊúâÂΩìt0ÊòØÊú™Êù•Êó∂Èó¥ÊàñË∂ÖËøá48Â∞èÊó∂ÂâçÊâç‰øÆÊ≠£
                const twoDaysAgo = now - 48 * 60 * 60 * 1000;
                
                if (t0 > maxFutureTime) {
                    console.warn(`‚ö†Ô∏è Timestamp is in the future: ${new Date(t0).toLocaleString()} (${t0})`);
                    console.warn(`Current time: ${new Date(now).toLocaleString()} (${now})`);
                    console.warn(`Time difference: ${hoursDiff.toFixed(2)} hours`);
                    // Â¶ÇÊûúÊó∂Èó¥Êà≥ÊòØÊú™Êù•ÁöÑÔºåËØ¥ÊòéÂèØËÉΩÊòØÊó∂Âå∫ÈóÆÈ¢òÔºå‰ΩøÁî®ÂΩìÂâçÊó∂Èó¥ÂæÄÂâçÊé®24Â∞èÊó∂
                    t0 = now - 24 * 60 * 60 * 1000; // 24Â∞èÊó∂Ââç
                    console.log(`‚úÖ Corrected start time: ${new Date(t0).toLocaleString()}`);
                } else if (t0 < twoDaysAgo) {
                    // Â¶ÇÊûúÊó∂Èó¥Êà≥Ë∂ÖËøá48Â∞èÊó∂ÂâçÔºåËØ¥ÊòéÊï∞ÊçÆÂ§™ÊóßÔºå‰ΩøÁî®ÂΩìÂâçÊó∂Èó¥ÂæÄÂâçÊé®24Â∞èÊó∂
                    console.warn(`‚ö†Ô∏è Timestamp is too old: ${new Date(t0).toLocaleString()} (${t0})`);
                    console.warn(`Current time: ${new Date(now).toLocaleString()} (${now})`);
                    console.warn(`Time difference: ${hoursDiff.toFixed(2)} hours`);
                    t0 = now - 24 * 60 * 60 * 1000; // 24Â∞èÊó∂Ââç
                    console.log(`‚úÖ Corrected start time: ${new Date(t0).toLocaleString()}`);
                } else {
                    console.log(`‚úì Timestamp normal: ${new Date(t0).toLocaleString()} (time difference: ${hoursDiff.toFixed(2)} hours)`);
                    console.log(`  History data end time: ${new Date(historyEndTime).toLocaleString()}`);
                }

                // Ê£ÄÊü•ÂâçÂá†‰∏™Êï∞ÊçÆÁÇπÁöÑÂÄºÔºåÁî®‰∫éË∞ÉËØï
                console.log(`üìä History data: ${points.length} points, everySec=${everySec}, t0=${new Date(t0).toLocaleString()}`);
                console.log(`üîç Ââç5‰∏™Êï∞ÊçÆÁÇπ:`, points.slice(0, 5));
                console.log(`üîç Âêé5‰∏™Êï∞ÊçÆÁÇπ:`, points.slice(-5));
                
                // ÁªüËÆ°Êï∞ÊçÆÁÇπÁ±ªÂûã
                const nullCount = points.filter(p => p === null).length;
                const undefinedCount = points.filter(p => p === undefined).length;
                const numberCount = points.filter(p => typeof p === 'number' && !isNaN(p)).length;
                const stringCount = points.filter(p => typeof p === 'string').length;
                const validNumberCount = points.filter(p => {
                    if (p === null || p === undefined) return false;
                    const num = typeof p === 'string' ? parseFloat(p) : Number(p);
                    return !isNaN(num) && isFinite(num);
                }).length;
                console.log(`üìà Data point statistics: null=${nullCount}, undefined=${undefinedCount}, number=${numberCount}, string=${stringCount}, valid=${validNumberCount}`);

                // Clear existing chart data (Ê∏ÖÁ©∫Ê∏©Â∫¶„ÄÅÊπøÂ∫¶ÂíåÂÖâÁÖßÂõæË°®)
                temperatureChart.data.labels = [];
                temperatureChart.data.datasets[0].data = [];
                if (temperatureChart.data.datasets[1]) {
                    temperatureChart.data.datasets[1].data = [];
                }
                humidityChart.data.labels = [];
                humidityChart.data.datasets[0].data = [];
                if (lightChart) {
                    lightChart.data.labels = [];
                    lightChart.data.datasets[0].data = [];
                }

                // Generate time labels and populate chart data
                let validPointCount = 0;
                
                // Áõ¥Êé•ÊòæÁ§∫ÊâÄÊúâÊï∞ÊçÆÁÇπÔºà‰ªéÊï∞ÁªÑÂºÄÂ§¥Âà∞ÁªìÂ∞æÔºâ
                // bridgeÂèëÈÄÅÁöÑÂÆûÈôÖÁÇπÊï∞Ôºö144‰∏™ÁÇπÔºà24Â∞èÊó∂ √ó 6‰∏™10ÂàÜÈíüÈó¥ÈöîÔºâ
                // ‰∏çÈúÄË¶ÅÊü•ÊâæÊúâÊïàÊï∞ÊçÆÁÇπÔºåÂõ†‰∏∫Êàë‰ª¨Â∑≤ÁªèÂàùÂßãÂåñ‰∫ÜÊµãËØïÊï∞ÊçÆ
                const startIndex = 0;
                const totalPoints = points.length;  // ÂÆûÈôÖÊï∞ÊçÆÁÇπÊï∞ÈáèÔºàÂ∫îËØ•ÊòØ144Ôºâ
                historyDataPointCount = totalPoints;  // ‰øùÂ≠òÂÆûÈôÖÁöÑÂéÜÂè≤Êï∞ÊçÆÁÇπÊï∞ÈáèÔºå‰æõÂÆûÊó∂Êõ¥Êñ∞Êó∂‰ΩøÁî®
                console.log(`üìä History data point count: ${totalPoints} (bridge config: 144 points, every 10 minutes)`);
                
                // Ê≥®ÊÑèÔºöhumidityPoints Âíå lightPoints Â∑≤Âú®ÂâçÈù¢Ëé∑ÂèñÔºà2984-2985Ë°åÔºâÔºåËøôÈáå‰∏çÈúÄË¶ÅÂÜçÊ¨°Ëé∑Âèñ
                
                for (let i = 0; i < points.length; i++) {
                    // ËÆ°ÁÆóÊØè‰∏™Êï∞ÊçÆÁÇπÁöÑÊó∂Èó¥Êà≥Ôºàt0ÊòØÊØ´ÁßíÔºåfinalEverySecÊòØÁßíÔºâ
                    const timestamp = t0 + i * finalEverySec * 1000;
                    const date = new Date(timestamp);
                    
                    // Ë∞ÉËØïÔºöÊâìÂç∞Ââç5‰∏™Êï∞ÊçÆÁÇπÁöÑÊó∂Èó¥Êà≥
                    if (i < 5) {
                        console.log(`  [${i}] timestamp=${timestamp}, date=${date.toLocaleString()}, value=${points[i]}`);
                    }
                    
                    // ‰ΩøÁî®Êó∂Èó¥Êà≥‰Ωú‰∏∫Ê†áÁ≠æÔºàChart.js time scale‰ºöËá™Âä®Ê†ºÂºèÂåñÔºâ
                    temperatureChart.data.labels.push(date);
                    humidityChart.data.labels.push(date);
                    if (lightChart) {
                        lightChart.data.labels.push(date);
                    }

                    // Add temperature data (Â∞ÜnullËΩ¨Êç¢‰∏∫0.0ÔºåÁ°Æ‰øùÂõæË°®ËÉΩÊ≠£Â∏∏ÊòæÁ§∫)
                    const tempValue = points[i];
                    
                    // ËΩ¨Êç¢Ê∏©Â∫¶Êï∞ÊçÆ‰∏∫Êï∞Â≠óÔºàÂ§ÑÁêÜÂ≠óÁ¨¶‰∏≤Á±ªÂûãÁöÑÊï∞Â≠óÔºâ
                    let tempNumValue = 0.0;  // ÈªòËÆ§ÂÄº0.0
                    if (tempValue !== null && tempValue !== undefined && tempValue !== '') {
                        // Â∞ùËØïËΩ¨Êç¢‰∏∫Êï∞Â≠ó
                        const converted = typeof tempValue === 'string' ? parseFloat(tempValue) : Number(tempValue);
                        if (!isNaN(converted) && isFinite(converted)) {
                            tempNumValue = converted;
                        }
                    }
                    // Â¶ÇÊûútempValueÊòØnull/undefined/Á©∫Â≠óÁ¨¶‰∏≤Ôºå‰ΩøÁî®ÈªòËÆ§ÂÄº0.0
                    
                    // Ê∑ªÂä†Âà∞Ê∏©Â∫¶ÂõæË°®Ôºà‰ΩøÁî®ËΩ¨Êç¢ÂêéÁöÑÊï∞Â≠óÔºånullÂ∑≤ËΩ¨Êç¢‰∏∫0.0Ôºâ
                    temperatureChart.data.datasets[0].data.push(tempNumValue);

                    // Add humidity data (Â∞ÜnullËΩ¨Êç¢‰∏∫nullÔºåËÆ©Chart.jsÂ§ÑÁêÜnullÂÄº)
                    const humidityValue = humidityPoints[i];
                    let humidityNumValue = null;  // ÈªòËÆ§ÂÄºnullÔºåËÆ©Chart.jsË∑≥ËøáËøô‰∏™ÁÇπ
                    if (humidityValue !== null && humidityValue !== undefined && humidityValue !== '') {
                        // Â∞ùËØïËΩ¨Êç¢‰∏∫Êï∞Â≠ó
                        const converted = typeof humidityValue === 'string' ? parseFloat(humidityValue) : Number(humidityValue);
                        if (!isNaN(converted) && isFinite(converted)) {
                            humidityNumValue = converted;
                        }
                    }
                    // Â¶ÇÊûúhumidityValueÊòØnull/undefined/Á©∫Â≠óÁ¨¶‰∏≤Ôºå‰øùÊåÅnullÔºà‰∏çÊòæÁ§∫Ëøô‰∏™ÁÇπÔºâ
                    
                    // Ê∑ªÂä†Âà∞ÊπøÂ∫¶ÂõæË°®Ôºà‰ΩøÁî®ËΩ¨Êç¢ÂêéÁöÑÊï∞Â≠óÔºånullÂÄº‰ºöË¢´Chart.jsË∑≥ËøáÔºâ
                    humidityChart.data.datasets[0].data.push(humidityNumValue);
                    
                    // Add light data (Â∞ÜnullËΩ¨Êç¢‰∏∫nullÔºåËÆ©Chart.jsÂ§ÑÁêÜnullÂÄº)
                    if (lightChart) {
                        const lightValue = lightPoints[i];
                        let lightBrightness = null;  // ÈªòËÆ§ÂÄºnullÔºåËÆ©Chart.jsË∑≥ËøáËøô‰∏™ÁÇπ
                        if (lightValue !== null && lightValue !== undefined && lightValue !== '') {
                            // ËΩ¨Êç¢ÂÖâÁÖßÊï∞ÊçÆÔºàÂèØËÉΩÊòØADCÂÄºÊàñÁôæÂàÜÊØîÔºâ
                            const converted = typeof lightValue === 'string' ? parseFloat(lightValue) : Number(lightValue);
                            if (!isNaN(converted) && isFinite(converted)) {
                                // Â¶ÇÊûúÂÄºÂú®0-4095ËåÉÂõ¥ÂÜÖÔºåËÆ§‰∏∫ÊòØADCÂÄºÔºåËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
                                if (converted >= 0 && converted <= 4095) {
                                    lightBrightness = 100.0 - (converted * 100.0 / 4095.0);
                                } else if (converted >= 0 && converted <= 100) {
                                    // Â¶ÇÊûúÂÄºÂú®0-100ËåÉÂõ¥ÂÜÖÔºåËÆ§‰∏∫ÊòØÁôæÂàÜÊØî
                                    lightBrightness = converted;
                                }
                            }
                        }
                        // Â¶ÇÊûúlightValueÊòØnull/undefined/Á©∫Â≠óÁ¨¶‰∏≤Ôºå‰øùÊåÅnullÔºà‰∏çÊòæÁ§∫Ëøô‰∏™ÁÇπÔºâ
                        lightChart.data.datasets[0].data.push(lightBrightness);
                    }
                    
                    // ËÆ°ÁÆóÂπ∂Ê∑ªÂä†ÁÉ≠ËÉÅËø´Âå∫ÂüüÊï∞ÊçÆ
                    if (temperatureChart.data.datasets[1]) {
                        // Âà§Êñ≠ÂΩìÂâçÊó∂Èó¥ÁÇπÊòØÂê¶Â§Ñ‰∫éÁÉ≠ËÉÅËø´Áä∂ÊÄÅ
                        // Ê≥®ÊÑèÔºöÂ¶ÇÊûútempNumValueÊòØÈªòËÆ§ÂÄº0.0‰∏îhumidityNumValueÊòØÈªòËÆ§ÂÄº50.0ÔºåËØ¥ÊòéÊòØÂàùÂßãÊï∞ÊçÆÔºå‰∏çÂ∫îËØ•Âà§Êñ≠‰∏∫ÁÉ≠ËÉÅËø´
                        const isRealData = (tempValue !== null && tempValue !== undefined && tempValue !== '') || 
                                         (humidityValue !== null && humidityValue !== undefined && humidityValue !== '');
                        const isStress = isRealData && isHeatStressCondition(tempNumValue, humidityNumValue);
                        if (isStress && tempNumValue !== null) {
                            // Â¶ÇÊûúÂ§Ñ‰∫éÁÉ≠ËÉÅËø´Áä∂ÊÄÅÔºåÊòæÁ§∫Ê∏©Â∫¶ÂÄºÔºàÁî®‰∫éÂ°´ÂÖÖÂå∫ÂüüÔºâ
                            temperatureChart.data.datasets[1].data.push(tempNumValue);
                        } else {
                            // Âê¶ÂàôÊòæÁ§∫nullÔºà‰∏çÂ°´ÂÖÖÔºâ
                            temperatureChart.data.datasets[1].data.push(null);
                        }
                    }

                    // ÁªüËÆ°ÊúâÊïàÊï∞ÊçÆÁÇπÔºàÂåÖÊã¨0ÂÄºÔºå‰ΩÜ‰∏çÂåÖÊã¨null/undefined/NaNÔºâ
                    if (tempNumValue !== null && tempNumValue !== undefined) {
                        validPointCount++;
                    }
                }

                // Êõ¥Êñ∞ÂõæË°®ÁöÑÊó∂Èó¥ËΩ¥ËåÉÂõ¥
                // ‰ΩøÁî®ÂéÜÂè≤Êï∞ÊçÆÁöÑÂÆûÈôÖÊó∂Èó¥ËåÉÂõ¥Ôºå‰ΩÜÁ°Æ‰øùËá≥Â∞ëÊòæÁ§∫24Â∞èÊó∂Á™óÂè£
                const historyStartTime = t0;
                // historyEndTime Â∑≤Âú®ÂâçÈù¢Â£∞ÊòéÔºåÁõ¥Êé•‰ΩøÁî®
                // now Â∑≤Âú®ÂâçÈù¢Â£∞ÊòéÔºåÁõ¥Êé•‰ΩøÁî®
                
                // ÂõæË°®Êó∂Èó¥ËΩ¥ËåÉÂõ¥Ôºö‰ªéÂéÜÂè≤Êï∞ÊçÆËµ∑ÂßãÊó∂Èó¥Âà∞ÂΩìÂâçÊó∂Èó¥ÔºàÊàñÂéÜÂè≤Êï∞ÊçÆÁªìÊùüÊó∂Èó¥ÔºåÂèñËæÉÊôöÁöÑÔºâ
                const chartMinTime = new Date(Math.min(historyStartTime, now - 24 * 60 * 60 * 1000));
                const chartMaxTime = new Date(Math.max(historyEndTime, now));
                
                console.log(`üìÖ Chart time axis range: ${chartMinTime.toLocaleString()} ~ ${chartMaxTime.toLocaleString()}`);
                console.log(`   History data range: ${new Date(historyStartTime).toLocaleString()} ~ ${new Date(historyEndTime).toLocaleString()}`);
                
                temperatureChart.options.scales.x.min = chartMinTime;
                temperatureChart.options.scales.x.max = chartMaxTime;
                humidityChart.options.scales.x.min = chartMinTime;
                humidityChart.options.scales.x.max = chartMaxTime;
                if (lightChart) {
                    lightChart.options.scales.x.min = chartMinTime;
                    lightChart.options.scales.x.max = chartMaxTime;
                }
                
                // Ë∞ÉËØïÔºöÊâìÂç∞ÂõæË°®Êï∞ÊçÆÁä∂ÊÄÅ
                console.log(`üìä Chart data status:`);
                console.log(`  Temperature chart: ${temperatureChart.data.labels.length} labels, ${temperatureChart.data.datasets[0].data.length} data points`);
                console.log(`  Humidity chart: ${humidityChart.data.labels.length} labels, ${humidityChart.data.datasets[0].data.length} data points`);
                if (lightChart) {
                    console.log(`  Light chart: ${lightChart.data.labels.length} labels, ${lightChart.data.datasets[0].data.length} data points`);
                }
                console.log(`  Time axis range: ${chartMinTime.toLocaleString()} ~ ${chartMaxTime.toLocaleString()}`);
                
                // ÊâìÂç∞ÂâçÂá†‰∏™ÂíåÂêéÂá†‰∏™Êï∞ÊçÆÁÇπÁöÑËØ¶ÁªÜ‰ø°ÊÅØÔºàÁî®‰∫éË∞ÉËØïÔºâ
                if (temperatureChart.data.datasets[0].data.length > 0) {
                    console.log(`  Temperature data point examples (first 5):`, temperatureChart.data.datasets[0].data.slice(0, 5));
                    console.log(`  Temperature data point examples (last 5):`, temperatureChart.data.datasets[0].data.slice(-5));
                    console.log(`  Temperature label examples (first 5):`, temperatureChart.data.labels.slice(0, 5).map(d => new Date(d).toLocaleString()));
                    console.log(`  Temperature label examples (last 5):`, temperatureChart.data.labels.slice(-5).map(d => new Date(d).toLocaleString()));
                }
                
                // Update charts with animation (Êõ¥Êñ∞Ê∏©Â∫¶„ÄÅÊπøÂ∫¶ÂíåÂÖâÁÖßÂõæË°®)
                console.log('üîÑ Updating charts...');
                
                // Âº∫Âà∂Êõ¥Êñ∞ÂõæË°®ÔºåÁ¶ÅÁî®Âä®Áîª‰ª•Á°Æ‰øùÁ´ãÂç≥ÊòæÁ§∫
                try {
                    temperatureChart.update('none');
                    console.log('‚úÖ Temperature chart updated');
                } catch (e) {
                    console.error('‚ùå Temperature chart update failed:', e);
                }
                
                try {
                    humidityChart.update('none');
                    console.log('‚úÖ Humidity chart updated');
                } catch (e) {
                    console.error('‚ùå Humidity chart update failed:', e);
                }
                
                if (lightChart) {
                    try {
                        lightChart.update('none');
                        console.log('‚úÖ Light chart updated');
                    } catch (e) {
                        console.error('‚ùå Light chart update failed:', e);
                    }
                }
                
                // È™åËØÅÂõæË°®Êï∞ÊçÆ
                console.log('üìä Chart update verification:');
                console.log(`  Temperature chart data point count: ${temperatureChart.data.datasets[0].data.length}`);
                console.log(`  Humidity chart data point count: ${humidityChart.data.datasets[0].data.length}`);
                if (lightChart) {
                    console.log(`  Light chart data point count: ${lightChart.data.datasets[0].data.length}`);
                }
                
                // Ê£ÄÊü•ÊòØÂê¶ÊúâÈùûÈõ∂Êï∞ÊçÆÁÇπ
                const nonZeroTempPoints = temperatureChart.data.datasets[0].data.filter(v => v !== 0 && v !== null && v !== undefined);
                console.log(`  Temperature chart non-zero data points: ${nonZeroTempPoints.length}`);
                if (nonZeroTempPoints.length > 0) {
                    console.log(`  Temperature chart non-zero data point examples:`, nonZeroTempPoints.slice(0, 5));
                }
                
                // È™åËØÅÊó∂Èó¥ËΩ¥ËåÉÂõ¥
                console.log(`  Temperature chart time axis range: ${temperatureChart.options.scales.x.min?.toLocaleString()} ~ ${temperatureChart.options.scales.x.max?.toLocaleString()}`);
                
                // Âº∫Âà∂ÈáçÊñ∞Ê∏≤ÊüìÂõæË°®ÔºàÁ°Æ‰øùÊï∞ÊçÆÂèØËßÅÔºâ
                setTimeout(() => {
                    try {
                        temperatureChart.resize();
                        humidityChart.resize();
                        if (lightChart) {
                            lightChart.resize();
                        }
                        console.log('‚úÖ Charts forcefully resized');
                    } catch (e) {
                        console.warn('‚ö†Ô∏è Chart resize failed (chart may not be fully initialized):', e);
                    }
                }, 100);
                
                console.log('‚úÖ Chart update completed');

                // ‰ªéÂéÜÂè≤Êï∞ÊçÆ‰∏≠ÊÅ¢Â§çÁÉ≠ËÉÅËø´ÂéÜÂè≤ÔºàËøáÂéª2Â∞èÊó∂ÂÜÖÁöÑÊï∞ÊçÆÔºâ
                // ÈáçÁî®ÂáΩÊï∞ÂºÄÂ§¥Â∑≤Â£∞ÊòéÁöÑ now ÂèòÈáè
                const cutoffTime = now - HEAT_STRESS_WINDOW_MS; // 2Â∞èÊó∂Ââç
                heatStressHistory = []; // Ê∏ÖÁ©∫Áé∞ÊúâÂéÜÂè≤
                
                // ÈÅçÂéÜÂéÜÂè≤Êï∞ÊçÆÔºåÊèêÂèñËøáÂéª2Â∞èÊó∂ÂÜÖÁöÑÊï∞ÊçÆÁÇπ
                for (let i = 0; i < points.length; i++) {
                    const timestamp = t0 + i * finalEverySec * 1000;
                    
                    // Âè™Â§ÑÁêÜËøáÂéª2Â∞èÊó∂ÂÜÖÁöÑÊï∞ÊçÆÁÇπ
                    if (timestamp >= cutoffTime && timestamp <= now) {
                        const tempValue = points[i];
                        const humidityValue = humidityPoints[i];
                        
                        // ËΩ¨Êç¢Ê∏©Â∫¶Êï∞ÊçÆ
                        let tempNumValue = null;
                        if (tempValue !== null && tempValue !== undefined && tempValue !== '') {
                            const converted = typeof tempValue === 'string' ? parseFloat(tempValue) : Number(tempValue);
                            if (!isNaN(converted) && isFinite(converted)) {
                                tempNumValue = converted;
                            }
                        }
                        
                        // ËΩ¨Êç¢ÊπøÂ∫¶Êï∞ÊçÆ
                        let humidityNumValue = null;
                        if (humidityValue !== null && humidityValue !== undefined && humidityValue !== '') {
                            const converted = typeof humidityValue === 'string' ? parseFloat(humidityValue) : Number(humidityValue);
                            if (!isNaN(converted) && isFinite(converted)) {
                                humidityNumValue = converted;
                            }
                        }
                        
                        // Â¶ÇÊûúÊ∏©Â∫¶ÂíåÊπøÂ∫¶Êï∞ÊçÆÈÉΩÊúâÊïàÔºà‰∏çÊòØÈªòËÆ§ÂÄºÔºâÔºåÊ∑ªÂä†Âà∞ÁÉ≠ËÉÅËø´ÂéÜÂè≤
                        // Ê£ÄÊü•ÊòØÂê¶ÊòØÁúüÂÆûÊï∞ÊçÆÔºà‰∏çÊòØ‰ªénullËΩ¨Êç¢Êù•ÁöÑÈªòËÆ§ÂÄºÔºâ
                        const isRealTempData = tempValue !== null && tempValue !== undefined && tempValue !== '';
                        const isRealHumidityData = humidityValue !== null && humidityValue !== undefined && humidityValue !== '';
                        
                        if (isRealTempData && isRealHumidityData) {
                            const isStress = isHeatStressCondition(tempNumValue, humidityNumValue);
                            heatStressHistory.push({
                                timestamp: timestamp,
                                temperature: tempNumValue,
                                humidity: humidityNumValue,
                                isStress: isStress
                            });
                        }
                    }
                }
                
                // ÊåâÊó∂Èó¥Êà≥ÊéíÂ∫èÔºàÁ°Æ‰øùÈ°∫Â∫èÊ≠£Á°ÆÔºâ
                heatStressHistory.sort((a, b) => a.timestamp - b.timestamp);
                
                console.log(`‚úÖ Recovered ${heatStressHistory.length} heat stress history data points from history data (past 2 hours)`);

                // ‰ªéÂéÜÂè≤Êï∞ÊçÆ‰∏≠ÊÅ¢Â§çÂÖâÁÖßÁ¥ØÁßØÂÄºÔºà‰ªäÂ§©ÁöÑÊï∞ÊçÆÔºâ
                // Ê≥®ÊÑèÔºöÂéÜÂè≤Êï∞ÊçÆÂèØËÉΩ‰∏çÂåÖÂê´ÂÖâÁÖßÊï∞ÊçÆÔºåËøôÈáåÂÖàÂ∞ùËØïÊÅ¢Â§ç
                updateTodayStartTime();
                const todayStart = todayStartTime;
                lightHistory = [];
                todayLightAccumulation = 0;
                
                // Â¶ÇÊûúÂéÜÂè≤Êï∞ÊçÆ‰∏≠ÊúâÂÖâÁÖßÊï∞ÊçÆÔºåÂ∞ùËØïÊÅ¢Â§ç
                // ËøôÈáåÂÅáËÆæÂéÜÂè≤Êï∞ÊçÆÊ†ºÂºèÂèØËÉΩÂåÖÂê´light_pointsÂ≠óÊÆµÔºàÁ±ª‰ººhumidity_pointsÔºâ
                // Â¶ÇÊûúÊ≤°ÊúâÔºåÂàô‰ªéÂÆûÊó∂Êï∞ÊçÆÂºÄÂßãÁ¥ØÁßØ
                const lightPointsForRecovery = historyData.light_points || [];
                if (lightPointsForRecovery.length > 0) {
                    console.log(`üìä Found light history data, total ${lightPointsForRecovery.length} data points`);
                    for (let i = 0; i < lightPointsForRecovery.length && i < points.length; i++) {
                        const timestamp = t0 + i * finalEverySec * 1000;
                        
                        // Âè™Â§ÑÁêÜ‰ªäÂ§©ÁöÑÊï∞ÊçÆÁÇπ
                        if (timestamp >= todayStart && timestamp <= now) {
                            const lightValue = lightPointsForRecovery[i];
                            if (lightValue !== null && lightValue !== undefined && lightValue !== '') {
                                // ËΩ¨Êç¢ÂÖâÁÖßÊï∞ÊçÆÔºàÂèØËÉΩÊòØADCÂÄºÊàñÁôæÂàÜÊØîÔºâ
                                let lightBrightness = null;
                                const converted = typeof lightValue === 'string' ? parseFloat(lightValue) : Number(lightValue);
                                if (!isNaN(converted) && isFinite(converted)) {
                                    // Â¶ÇÊûúÂÄºÂú®0-4095ËåÉÂõ¥ÂÜÖÔºåËÆ§‰∏∫ÊòØADCÂÄºÔºåËΩ¨Êç¢‰∏∫ÁôæÂàÜÊØî
                                    if (converted >= 0 && converted <= 4095) {
                                        lightBrightness = 100.0 - (converted * 100.0 / 4095.0);
                                    } else if (converted >= 0 && converted <= 100) {
                                        // Â¶ÇÊûúÂÄºÂú®0-100ËåÉÂõ¥ÂÜÖÔºåËÆ§‰∏∫ÊòØÁôæÂàÜÊØî
                                        lightBrightness = converted;
                                    }
                                }
                                
                                if (lightBrightness !== null) {
                                    // Use actual interval from bridge (finalEverySec is in seconds, convert to minutes)
                                    const intervalMinutes = finalEverySec / 60;  // 600 seconds = 10 minutes
                                    const dli = calculateDLI(lightBrightness, intervalMinutes);
                                    lightHistory.push({
                                        timestamp: timestamp,
                                        brightness: lightBrightness,
                                        dli: dli
                                    });
                                }
                            }
                        }
                    }
                    
                    // ËÆ°ÁÆó‰ªäÊó•Á¥ØËÆ°ÂÄº
                    todayLightAccumulation = lightHistory.reduce((sum, item) => sum + item.dli, 0);
                    console.log(`‚úÖ Recovered ${lightHistory.length} light data points from history data, today's accumulation: ${todayLightAccumulation.toFixed(1)} DLI-lite`);
                } else {
                    console.log('‚ÑπÔ∏è History data does not contain light data, will start accumulating from real-time data');
                }

                addLog(`History data loaded: ${validPointCount}/${points.length} valid data points (bridge config: 144 points, every 10 minutes)`, 'success');
                console.log(`‚úÖ Loaded ${validPointCount} valid temperature data points, total ${points.length} data points (bridge config: 144 points, every 10 minutes interval)`);
                
                // Ê†áËÆ∞ÂéÜÂè≤Êï∞ÊçÆÂ∑≤Âä†ËΩΩÔºåÂêéÁª≠‰∏çÂÜçÂ§ÑÁêÜÂéÜÂè≤Êï∞ÊçÆÊ∂àÊÅØ
                historyLoaded = true;
                console.log('‚úÖ History data loading completed, will ignore subsequent history data messages');
            } catch (error) {
                addLog(`Â§ÑÁêÜÂéÜÂè≤Êï∞ÊçÆÊó∂Âá∫Èîô: ${error.message}`, 'error');
                console.error('History data processing error:', error, error.stack);
            }
        }

        // Connect to MQTT server
        function connectMQTT() {
            if (!MQTT_CONFIG) {
                addLog('MQTT configuration not loaded. Cannot connect.', 'error');
                updateStatus('disconnected', 'Config Not Loaded');
                return;
            }
            
            updateStatus('connecting', 'Connecting...');
            addLog('Connecting to MQTT server...', 'info');
            
            try {
                mqttClient = mqtt.connect(MQTT_CONFIG.host, MQTT_CONFIG.options);
                
                mqttClient.on('connect', () => {
                    updateStatus('connected', 'Connected');
                    addLog('Successfully connected to MQTT server!', 'success');
                    
                    // First, subscribe to history topic to get historical data
                    // Use QoS 1 to ensure we get the retained message
                    console.log('üì° Preparing to subscribe to history data topic:', MQTT_CONFIG.topicHistory);
                    mqttClient.subscribe(MQTT_CONFIG.topicHistory, { qos: 1 }, (err) => {
                        if (err) {
                            addLog(`Failed to subscribe to history data topic: ${err.message}`, 'error');
                            console.error('‚ùå History topic subscription error:', err);
                            // If history subscription fails, still subscribe to real-time data
                            subscribeToRealTimeTopics();
                        } else {
                            addLog(`Subscribed to history data topic: ${MQTT_CONFIG.topicHistory}`, 'success');
                            console.log('‚úÖ Subscribed to history data topic:', MQTT_CONFIG.topicHistory);
                            console.log('üìã MQTT config:', {
                                historyTopic: MQTT_CONFIG.topicHistory,
                                historyRequestTopic: MQTT_CONFIG.topicHistoryRequest,
                                connected: mqttClient.connected
                            });
                            
                            // Á≠âÂæÖ‰∏ÄÂ∞èÊÆµÊó∂Èó¥Á°Æ‰øùËÆ¢ÈòÖÂÆåÊàêÔºåÊ£ÄÊü•ÊòØÂê¶Êî∂Âà∞retainedÊ∂àÊÅØ
                            // Â¶ÇÊûúbridgeÂ∑≤ÁªèÂèëÂ∏É‰∫ÜretainedÊ∂àÊÅØÔºåËÆ¢ÈòÖÊó∂‰ºöËá™Âä®Êî∂Âà∞
                            setTimeout(() => {
                                if (!historyLoaded) {
                                    // Â¶ÇÊûúÊ≤°ÊúâÊî∂Âà∞retainedÊ∂àÊÅØÔºåÂèëÈÄÅËØ∑Ê±Ç
                                    console.log('‚è∞ No retained message received, sending history data request...');
                                    sendHistoryRequest();
                                } else {
                                    console.log('‚úÖ Retained message received, no need to send request');
                                }
                            }, 1000); // Á≠âÂæÖ1ÁßíÊ£ÄÊü•ÊòØÂê¶Êî∂Âà∞retainedÊ∂àÊÅØ
                            
                            // Wait a bit for history data to arrive
                            setTimeout(() => {
                                if (!historyLoaded) {
                                    // Â¶ÇÊûúËøòÊ≤°Êî∂Âà∞ÔºåÂÜçÂèëÈÄÅ‰∏ÄÊ¨°ËØ∑Ê±ÇÔºàÈáçËØïÔºâ
                                    console.warn('‚ö†Ô∏è Still no history data received, retrying request...');
                                    sendHistoryRequest();
                                    
                                    // ÂÜçÁ≠âÂæÖ2Áßí
                                    setTimeout(() => {
                                        if (!historyLoaded) {
                                            addLog('‚ö†Ô∏è No history data received, continuing to subscribe to real-time data...', 'info');
                                            console.warn('‚ö†Ô∏è No history data received after retry');
                                            console.warn('   Possible reasons:');
                                            console.warn('   1. Bridge has not published history data yet');
                                            console.warn('   2. Retained message does not exist');
                                            console.warn('   3. Topic name mismatch');
                                            console.warn('   4. Network delay');
                                        } else {
                                            console.log('‚úÖ History data successfully loaded (after retry)');
                                        }
                                        subscribeToRealTimeTopics();
                                    }, 2000);
                                } else {
                                    console.log('‚úÖ History data successfully loaded');
                                    subscribeToRealTimeTopics();
                                }
                            }, 2500); // Wait 2.5 seconds for history data
                        }
                    });
                });
                
                // Helper function to subscribe to real-time topics
                function subscribeToRealTimeTopics() {
                    // Subscribe to sensor data topic
                    mqttClient.subscribe(MQTT_CONFIG.topicSensor, (err) => {
                        if (err) {
                            addLog(`Failed to subscribe to sensor topic: ${err.message}`, 'error');
                        } else {
                            addLog(`Subscribed to sensor topic: ${MQTT_CONFIG.topicSensor}`, 'success');
                        }
                    });
                    
                    // Subscribe to alert topic
                    mqttClient.subscribe(MQTT_CONFIG.topicAlert, (err) => {
                        if (err) {
                            addLog(`Failed to subscribe to alert topic: ${err.message}`, 'error');
                        } else {
                            addLog(`Subscribed to alert topic: ${MQTT_CONFIG.topicAlert}`, 'success');
                        }
                    });
                }
                
                mqttClient.on('message', (topic, message) => {
                    try {
                        let data;
                        try {
                            data = JSON.parse(message.toString());
                        } catch (parseError) {
                            // Â¶ÇÊûú‰∏çÊòØJSONÊ†ºÂºèÔºåÂèØËÉΩÊòØÂÖ∂‰ªñÁ±ªÂûãÁöÑÊ∂àÊÅØÔºåË∑≥Ëøá
                            if (topic === MQTT_CONFIG.topicHistory) {
                                console.error('‚ùå History data message parsing failed:', parseError);
                                addLog(`History data message parsing failed: ${parseError.message}`, 'error');
                            }
                            return;
                        }
                        
                        if (topic === MQTT_CONFIG.topicHistory) {
                            // Â¶ÇÊûúÂ∑≤ÁªèÂä†ËΩΩËøáÂéÜÂè≤Êï∞ÊçÆÔºåÁõ¥Êé•Ë∑≥Ëøá
                            if (historyLoaded) {
                                console.log('‚è≠Ô∏è History data already loaded, ignoring subsequent history data messages');
                                return;
                            }
                            // History data - process and populate charts
                            addLog('üì• Received history data, processing...', 'info');
                            console.log('üì• Received history data from topic:', topic);
                            console.log('üì¶ History data size:', message.length, 'bytes');
                            console.log('üìÖ Received time:', new Date().toLocaleString());
                            
                            // ËØ¶ÁªÜÊ£ÄÊü•Êï∞ÊçÆÊ†ºÂºè
                            console.log('üìã Raw data preview:', {
                                everySec: data.everySec,
                                t0: data.t0,
                                pointsLength: data.points ? data.points.length : 0,
                                humidityPointsLength: data.humidity_points ? data.humidity_points.length : 0,
                                lightPointsLength: data.light_points ? data.light_points.length : 0,
                                firstPoint: data.points ? data.points[0] : 'N/A',
                                firstPointType: data.points ? typeof data.points[0] : 'N/A',
                                lastPoint: data.points ? data.points[data.points.length - 1] : 'N/A',
                                lastPointType: data.points ? typeof data.points[data.points.length - 1] : 'N/A',
                                first5Points: data.points ? data.points.slice(0, 5) : 'N/A',
                                last5Points: data.points ? data.points.slice(-5) : 'N/A'
                            });
                            
                            // È™åËØÅÊï∞ÊçÆÁÇπÊï∞ÈáèÔºàÂ∫îËØ•ÊòØ144‰∏™Ôºå24Â∞èÊó∂ √ó 6‰∏™10ÂàÜÈíüÈó¥ÈöîÔºâ
                            if (data.points) {
                                if (data.points.length === 144) {
                                    console.log('‚úÖ Data point count correct: 144 points (24 hours √ó 6 ten-minute intervals)');
                                } else {
                                    console.warn(`‚ö†Ô∏è Abnormal data point count: received ${data.points.length} points, expected 144 points`);
                                    console.warn('   Bridge should send 144 points (every 10 minutes, 24 hours total)');
                                }
                            }
                            
                            // È™åËØÅeverySecÔºàÂ∫îËØ•ÊòØ600ÁßíÔºåÂç≥10ÂàÜÈíüÔºâ
                            if (data.everySec) {
                                if (data.everySec === 600) {
                                    console.log('‚úÖ Time interval correct: 600 seconds (10 minutes)');
                                } else {
                                    console.warn(`‚ö†Ô∏è Abnormal time interval: everySec=${data.everySec} seconds, expected 600 seconds (10 minutes)`);
                                }
                            }
                            
                            processHistoryData(data);
                        } else if (topic === MQTT_CONFIG.topicSensor) {
                            // Sensor data (real-time)
                            // Only log occasionally to avoid spam
                            if (Math.random() < 0.1) { // Log 10% of messages
                                addLog(`Received sensor data: Temperature ${data.temperature}¬∞C`, 'success');
                            }
                            updateSensorData(data);
                        } else if (topic === MQTT_CONFIG.topicAlert) {
                            // Alert message - translate if needed
                            const alertMessage = data.message || 'Unknown alert';
                            const translatedAlertMessage = translateAlertMessage(alertMessage);
                            addLog(`Received alert message: ${translatedAlertMessage}`, 'error');
                            addAlert(data.alert_type || 'Alert', alertMessage);
                            
                            // If it's an air quality alert, also log to event log
                            if (data.alert_type === 'air_quality') {
                                addEventLog('air_quality_alert', {
                                    message: translatedAlertMessage || 'Poor air quality persisted for more than 10 seconds, ventilation fan has been running for 10 seconds but air quality has not improved!',
                                    snapshot: {}
                                });
                            }
                            
                            // If it's a temperature alert, also log to event log
                            if (data.alert_type === 'temperature') {
                                addEventLog('temperature_alert', {
                                    message: translatedAlertMessage || 'Temperature exceeded threshold for more than 10 seconds, ventilation fan has been running for 10 seconds but temperature has not decreased!',
                                    snapshot: {}
                                });
                            }
                        }
                    } catch (e) {
                        addLog(`Message parsing error: ${e.message}`, 'error');
                        addLog(`Original message: ${message.toString()}`, 'info');
                    }
                });
                
                mqttClient.on('error', (error) => {
                    updateStatus('disconnected', 'Connection Error');
                    addLog(`MQTT error: ${error.message}`, 'error');
                });
                
                mqttClient.on('close', () => {
                    updateStatus('disconnected', 'Disconnected');
                    addLog('MQTT connection closed, attempting to reconnect...', 'error');
                });
                
                mqttClient.on('offline', () => {
                    updateStatus('disconnected', 'Offline');
                    addLog('MQTT client offline, attempting to reconnect...', 'error');
                });
                
                mqttClient.on('reconnect', () => {
                    updateStatus('connecting', 'Reconnecting...');
                    addLog('Reconnecting to MQTT server...', 'info');
                });
                
            } catch (error) {
                updateStatus('disconnected', 'Connection Failed');
                addLog(`Connection error: ${error.message}`, 'error');
            }
        }

        // Request browser notification permission
        if ('Notification' in window && Notification.permission === 'default') {
            Notification.requestPermission();
        }

        // Send RGB LED control command
        function sendRGBControlCommand(ledCount) {
            if (!mqttClient || !mqttClient.connected) {
                addLog('MQTT not connected, cannot send control command', 'error');
                return;
            }
            
            // Á´ãÂç≥Êõ¥Êñ∞ÁõÆÊ†áÂÄºÊòæÁ§∫
            targetLedCount = ledCount;
            targetLedSetTime = Date.now();
            const targetElement = document.getElementById('rgbLedTarget');
            if (targetElement) {
                targetElement.textContent = `${ledCount}/5`;
            }
            
            // ÊòæÁ§∫PendingÁä∂ÊÄÅ
            const pendingElement = document.getElementById('rgbLedPending');
            if (pendingElement) {
                pendingElement.style.display = 'inline';
            }
            
            const command = {
                rgb_led_count: ledCount
            };
            
            const message = JSON.stringify(command);
            mqttClient.publish(MQTT_CONFIG.topicControl, message, { qos: 1 }, (err) => {
                if (err) {
                    addLog(`Failed to send control command: ${err.message}`, 'error');
                    // ÂèëÈÄÅÂ§±Ë¥•ÔºåÊ∏ÖÈô§ÁõÆÊ†áÂÄº
                    targetLedCount = null;
                    targetLedSetTime = null;
                    if (targetElement) {
                        targetElement.textContent = '--';
                    }
                    if (pendingElement) {
                        pendingElement.style.display = 'none';
                    }
                } else {
                    addLog(`Control command sent: RGB LED count=${ledCount}`, 'success');
                    isManualMode = true;
                    const controlModeElement = document.getElementById('rgbControlMode');
                    if (controlModeElement) {
                        controlModeElement.textContent = 'Manual Mode';
                    }
                    
                    // ÂàáÊç¢Âà∞ÊâãÂä®Ê®°ÂºèÊ†áÁ≠æÈ°µ
                    switchToManualTab();
                    
                    // Â¶ÇÊûúÊâãÂä®ËÆæÁΩÆ‰∏∫0ÔºåÈáçÁΩÆËá™Âä®Ë°•ÂÖâÁä∂ÊÄÅÔºåÈÅøÂÖçËá™Âä®ÈÄªËæëÂÜçÊ¨°Ëß¶Âèë
                    if (ledCount === 0) {
                        lastEventState.lowLight = false;
                        lastEventState.supplementalLightOn = false;
                    }
                }
            });
        }

        // Send auto mode command
        function sendAutoModeCommand() {
            if (!mqttClient || !mqttClient.connected) {
                addLog('MQTT not connected, cannot send control command', 'error');
                return;
            }
            
            // Ê∏ÖÈô§ÁõÆÊ†áÂÄºÔºàËá™Âä®Ê®°Âºè‰∏ã‰∏çÈúÄË¶ÅÁõÆÊ†áÂÄºÔºâ
            targetLedCount = null;
            targetLedSetTime = null;
            const targetElement = document.getElementById('rgbLedTarget');
            if (targetElement) {
                targetElement.textContent = '--';
            }
            const pendingElement = document.getElementById('rgbLedPending');
            if (pendingElement) {
                pendingElement.style.display = 'none';
            }
            
            const command = {
                auto_mode: true
            };
            
            const message = JSON.stringify(command);
            mqttClient.publish(MQTT_CONFIG.topicControl, message, { qos: 1 }, (err) => {
                if (err) {
                    addLog(`Failed to send auto mode command: ${err.message}`, 'error');
                } else {
                    addLog('Auto mode command sent', 'success');
                    isManualMode = false;
                    const autoControlModeElement = document.getElementById('rgbAutoControlMode');
                    if (autoControlModeElement) {
                        autoControlModeElement.textContent = 'Auto Mode';
                    }
                    
                    // ÂàáÊç¢Âà∞Ëá™Âä®Ê®°ÂºèÊ†áÁ≠æÈ°µ
                    switchToAutoTab();
                    
                    document.getElementById('rgbLedSlider').value = 0;
                    document.getElementById('rgbLedSliderValue').textContent = '0';
                }
            });
        }

        // Fan manual control has been removed, now only supports automatic control via temperature threshold


        // Send history data request to bridge
        function sendHistoryRequest() {
            if (!mqttClient) {
                console.error('‚ùå MQTT client not initialized, cannot send history data request');
                addLog('MQTT client not initialized, cannot send history data request', 'error');
                return;
            }
            
            if (!mqttClient.connected) {
                console.warn('‚ö†Ô∏è MQTT not connected, cannot send history data request');
                console.warn('  Connection status:', {
                    connected: mqttClient.connected,
                    disconnecting: mqttClient.disconnecting,
                    reconnecting: mqttClient.reconnecting
                });
                addLog('MQTT not connected, cannot send history data request', 'error');
                return;
            }
            
            // ÂèëÈÄÅËØ∑Ê±ÇÊ∂àÊÅØÔºàÁÆÄÂçïÁöÑJSONÊ†ºÂºèÔºâ
            const request = {
                action: 'request_history',
                timestamp: Date.now()
            };
            
            const message = JSON.stringify(request);
            const requestTopic = MQTT_CONFIG.topicHistoryRequest;
            
            console.log('üì§ Preparing to send history data request:', {
                topic: requestTopic,
                message: message,
                timestamp: new Date().toISOString()
            });
            
            mqttClient.publish(requestTopic, message, { qos: 1 }, (err) => {
                if (err) {
                    console.error('‚ùå Failed to send history data request:', err);
                    console.error('  Error details:', {
                        message: err.message,
                        code: err.code,
                        topic: requestTopic
                    });
                    addLog(`Failed to send history data request: ${err.message}`, 'error');
                } else {
                    console.log('‚úÖ History data request sent successfully');
                    console.log('  Request Topic:', requestTopic);
                    console.log('  Request content:', message);
                    console.log('  Send time:', new Date().toISOString());
                    addLog(`History data request sent to ${requestTopic}`, 'success');
                }
            });
        }

        // Update temperature comparison display
        function updateTemperatureComparison(currentTemp, threshold) {
            const comparisonElement = document.getElementById('tempThresholdComparison');
            if (!comparisonElement) return;
            
            if (currentTemp === undefined || currentTemp === null || isNaN(currentTemp)) {
                comparisonElement.textContent = 'Waiting for temperature data...';
                comparisonElement.style.color = '#6c757d';
                return;
            }
            
            const diff = currentTemp - threshold;
            const absDiff = Math.abs(diff);
            
            if (diff > 0) {
                // Current temperature is above threshold
                comparisonElement.innerHTML = `
                    <span style="color: #dc3545; font-weight: 600;">Current Temperature ${currentTemp.toFixed(1)}¬∞C</span>
                    <span style="color: #6c757d;"> above threshold </span>
                    <span style="color: #dc3545; font-weight: 600;">${absDiff.toFixed(1)}¬∞C</span>
                    <div style="margin-top: 4px; font-size: 0.75em; color: #dc3545;">‚ö†Ô∏è Fan will automatically turn on</div>
                `;
            } else if (diff < 0) {
                // Current temperature is below threshold
                comparisonElement.innerHTML = `
                    <span style="color: #28a745; font-weight: 600;">Current Temperature ${currentTemp.toFixed(1)}¬∞C</span>
                    <span style="color: #6c757d;"> below threshold </span>
                    <span style="color: #28a745; font-weight: 600;">${absDiff.toFixed(1)}¬∞C</span>
                    <div style="margin-top: 4px; font-size: 0.75em; color: #28a745;">‚úì Temperature normal, fan off</div>
                `;
            } else {
                // Current temperature equals threshold
                comparisonElement.innerHTML = `
                    <span style="color: #ffc107; font-weight: 600;">Current Temperature ${currentTemp.toFixed(1)}¬∞C</span>
                    <span style="color: #6c757d;"> equals threshold</span>
                    <div style="margin-top: 4px; font-size: 0.75em; color: #ffc107;">‚ö° Near critical value</div>
                `;
            }
        }

        // Send temperature threshold command
        function sendTempThresholdCommand(threshold) {
            if (!mqttClient || !mqttClient.connected) {
                addLog('MQTT not connected, cannot send control command', 'error');
                return;
            }
            
            const thresholdValue = parseFloat(threshold);
            if (isNaN(thresholdValue) || thresholdValue < 25 || thresholdValue > 50) {
                addLog('Invalid temperature threshold. Range: 25.0-50.0¬∞C', 'error');
                return;
            }
            
            const msg = {
                temp_threshold: thresholdValue
            };
            
            const message = JSON.stringify(msg);
            console.log('Sending temperature threshold:', message);  // Debug log
            tempThresholdJustUpdated = true;  // Set flag to allow update even if slider is being used
            mqttClient.publish(MQTT_CONFIG.topicControl, message, { qos: 1 }, (err) => {
                if (err) {
                    addLog(`Failed to send temperature threshold command: ${err.message}`, 'error');
                    console.error('Temperature threshold publish error:', err);  // Debug log
                    tempThresholdJustUpdated = false;  // Reset flag on error
                } else {
                    addLog(`Temperature threshold set: ${thresholdValue}¬∞C`, 'success');
                    console.log('Temperature threshold published successfully');  // Debug log
                }
            });
        }

        // Initialize after page load
        window.addEventListener('DOMContentLoaded', async () => {
            // Initialize tab navigation
            initTabNavigation();
            initArrowPageNav();
            
            initTemperatureChart();
            initRealtimeTemperatureChart();
            initHumidityChart();
            initRealtimeHumidityChart();
            initLightChart();
            init24hChartSwitcher();
            addLog('Page loaded, initializing...', 'info');
            
            // Load configuration first, then connect to MQTT
            await loadConfig();
            if (MQTT_CONFIG) {
                connectMQTT();
            } else {
                addLog('Failed to initialize: Configuration not loaded', 'error');
            }
            
            // RGB LED control events
            const rgbLedSlider = document.getElementById('rgbLedSlider');
            const rgbLedSliderValue = document.getElementById('rgbLedSliderValue');
            const rgbLedSetBtn = document.getElementById('rgbLedSetBtn');
            const rgbLedAutoBtn = document.getElementById('rgbLedAutoBtn');
            
            // Update display when slider value changes
            rgbLedSlider.addEventListener('input', (e) => {
                rgbLedSliderValue.textContent = e.target.value;
            });
            
            // Set button click event
            rgbLedSetBtn.addEventListener('click', () => {
                const ledCount = parseInt(rgbLedSlider.value);
                sendRGBControlCommand(ledCount);
            });
            
            // Auto mode button click event
            rgbLedAutoBtn.addEventListener('click', () => {
                sendAutoModeCommand();
            });
            
            // Manual mode button in auto panel
            const rgbLedManualBtn = document.getElementById('rgbLedManualBtn');
            if (rgbLedManualBtn) {
                rgbLedManualBtn.addEventListener('click', () => {
                    // ÂàáÊç¢Âà∞ÊâãÂä®Ê®°ÂºèÊ†áÁ≠æÈ°µÔºå‰ΩÜ‰∏çÂèëÈÄÅÂëΩ‰ª§ÔºàËÆ©Áî®Êà∑ÊâãÂä®ËÆæÁΩÆÔºâ
                    switchToManualTab();
                });
            }
            
            // Initialize RGB mode tabs
            initRGBModeTabs();
            
            // Clear log button event
            const clearLogBtn = document.getElementById('clearLogBtn');
            if (clearLogBtn) {
                clearLogBtn.addEventListener('click', () => {
                    clearLog();
                });
            }
            
            // Fan manual control buttons have been removed from HTML
            // Fan now only supports automatic control via temperature threshold
            // Buzzer control has been removed from HTML
            
            // Temperature threshold control events
            const tempThresholdSetBtn = document.getElementById('tempThresholdSetBtn');
            const tempThresholdSlider = document.getElementById('tempThresholdSlider');
            const tempThresholdDisplay = document.getElementById('tempThresholdDisplay');
            
            if (tempThresholdSetBtn && tempThresholdSlider) {
                // Update display when slider value changes
                tempThresholdSlider.addEventListener('input', (e) => {
                    const value = parseFloat(e.target.value);
                    if (tempThresholdDisplay) {
                        tempThresholdDisplay.textContent = value.toFixed(1);
                    }
                });
                
                // Set button click event
                tempThresholdSetBtn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const threshold = tempThresholdSlider.value;
                    sendTempThresholdCommand(threshold);
                });
                
                // Preset button click events
                const presetButtons = document.querySelectorAll('.temp-preset-btn');
                presetButtons.forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const value = parseFloat(btn.getAttribute('data-value'));
                        
                        // Update slider and display
                        tempThresholdSlider.value = value;
                        if (tempThresholdDisplay) {
                            tempThresholdDisplay.textContent = value.toFixed(1);
                        }
                        
                        // Update preset button states
                        presetButtons.forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                        
                        // Auto-apply after a short delay (optional, or require Set button)
                        // For now, just update the slider, user still needs to click Set
                    });
                });
            } else {
                console.error('Temperature threshold control elements not found:', {
                    tempThresholdSetBtn: !!tempThresholdSetBtn,
                    tempThresholdSlider: !!tempThresholdSlider
                });
            }
        });

        // Disconnect when page closes
        window.addEventListener('beforeunload', () => {
            if (mqttClient) {
                mqttClient.end();
            }
        });
    </script>
</body>
</html>
